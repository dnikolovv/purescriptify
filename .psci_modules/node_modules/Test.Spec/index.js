"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Control_Monad_Fork_Class = require("../Control.Monad.Fork.Class/index.js");
var Control_Monad_Writer_Class = require("../Control.Monad.Writer.Class/index.js");
var Control_Monad_Writer_Trans = require("../Control.Monad.Writer.Trans/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect_AVar = require("../Effect.AVar/index.js");
var Effect_Aff_AVar = require("../Effect.Aff.AVar/index.js");
var Effect_Aff_Class = require("../Effect.Aff.Class/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Test_Spec_Tree = require("../Test.Spec.Tree/index.js");
var SpecT = function (x) {
    return x;
};
var MEmpty = (function () {
    function MEmpty() {

    };
    MEmpty.value = new MEmpty();
    return MEmpty;
})();
var MMemoized = (function () {
    function MMemoized(value0) {
        this.value0 = value0;
    };
    MMemoized.create = function (value0) {
        return new MMemoized(value0);
    };
    return MMemoized;
})();
var MFailed = (function () {
    function MFailed(value0) {
        this.value0 = value0;
    };
    MFailed.create = function (value0) {
        return new MFailed(value0);
    };
    return MFailed;
})();
var CleanUpWithContext = (function () {
    function CleanUpWithContext(value0) {
        this.value0 = value0;
    };
    CleanUpWithContext.create = function (value0) {
        return new CleanUpWithContext(value0);
    };
    return CleanUpWithContext;
})();
var TestWithName = (function () {
    function TestWithName(value0) {
        this.value0 = value0;
    };
    TestWithName.create = function (value0) {
        return new TestWithName(value0);
    };
    return TestWithName;
})();
var warn = function () {
    return {};
};
var setParallelizable = function (value) {
    return Data_Newtype.over()()(Test_Spec_Tree.Item)(function (i) {
        return {
            isParallelizable: Control_Alt.alt(Data_Maybe.altMaybe)(i.isParallelizable)(new Data_Maybe.Just(value)),
            example: i.example,
            isFocused: i.isFocused
        };
    });
};
var plusSpecT = function (dictPlus) {
    return Control_Monad_Writer_Trans.plusWriterT(dictPlus);
};

// | Create a pending spec.
var pending = function (dictMonad) {
    return function (name) {
        return Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid.monoidArray)(dictMonad))([ new Test_Spec_Tree.Leaf(name, Data_Maybe.Nothing.value) ]);
    };
};

// | Create a pending spec with a body that is ignored by
// | the runner. It can be useful for documenting what the
// | spec should test when non-pending.
var pending$prime = function (dictMonad) {
    return function (name) {
        return function (v) {
            return pending(dictMonad)(name);
        };
    };
};
var newtypeSpecT = {
    Coercible0: function () {
        return undefined;
    }
};
var monadZeroSpecT = function (dictMonadZero) {
    return Control_Monad_Writer_Trans.monadZeroWriterT(Data_Monoid.monoidArray)(dictMonadZero);
};
var monadTransSpecT = Control_Monad_Writer_Trans.monadTransWriterT(Data_Monoid.monoidArray);
var monadThrowSpecT = function (dictMonadThrow) {
    return Control_Monad_Writer_Trans.monadThrowWriterT(Data_Monoid.monoidArray)(dictMonadThrow);
};
var monadStateSpecT = function (dictMonadState) {
    return Control_Monad_Writer_Trans.monadStateWriterT(Data_Monoid.monoidArray)(dictMonadState);
};
var monadSpecT = function (dictMonad) {
    return Control_Monad_Writer_Trans.monadWriterT(Data_Monoid.monoidArray)(dictMonad);
};
var monadRecSpecT = function (dictMonadRec) {
    return Control_Monad_Writer_Trans.monadRecWriterT(Data_Monoid.monoidArray)(dictMonadRec);
};
var monadReaderSpecT = function (dictMonadReader) {
    return Control_Monad_Writer_Trans.monadReaderWriterT(Data_Monoid.monoidArray)(dictMonadReader);
};
var monadPlusSpecT = function (dictMonadPlus) {
    return Control_Monad_Writer_Trans.monadPlusWriterT(Data_Monoid.monoidArray)(dictMonadPlus);
};
var monadErrorSpecT = function (dictMonadError) {
    return Control_Monad_Writer_Trans.monadErrorWriterT(Data_Monoid.monoidArray)(dictMonadError);
};
var monadEffectWriter = function (dictMonadEffect) {
    return Control_Monad_Writer_Trans.monadEffectWriter(Data_Monoid.monoidArray)(dictMonadEffect);
};
var monadContSpecT = function (dictMonadCont) {
    return Control_Monad_Writer_Trans.monadContWriterT(Data_Monoid.monoidArray)(dictMonadCont);
};
var monadAskSpecT = function (dictMonadAsk) {
    return Control_Monad_Writer_Trans.monadAskWriterT(Data_Monoid.monoidArray)(dictMonadAsk);
};
var memoize = function (dictMonadAff) {
    return function (dictMonadError) {
        return function ($$var) {
            return function (action) {
                return Control_Bind.bind(((dictMonadAff.MonadEffect0()).Monad0()).Bind1())(Effect_Aff_Class.liftAff(dictMonadAff)(Effect_Aff_AVar.take($$var)))(function (v) {
                    if (v instanceof MFailed) {
                        return Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0())(Effect_Exception.error("exception in beforeAll-hook (see previous failure)"));
                    };
                    if (v instanceof MMemoized) {
                        return Control_Apply.applyFirst((((dictMonadAff.MonadEffect0()).Monad0()).Bind1()).Apply0())(Control_Applicative.pure(((dictMonadAff.MonadEffect0()).Monad0()).Applicative0())(v.value0))(Effect_Aff_Class.liftAff(dictMonadAff)(Effect_Aff_AVar.put(new MMemoized(v.value0))($$var)));
                    };
                    if (v instanceof MEmpty) {
                        return Control_Bind.bind(((dictMonadAff.MonadEffect0()).Monad0()).Bind1())(Control_Monad_Error_Class["try"](dictMonadError)(action))(function (res) {
                            return Control_Bind.discard(Control_Bind.discardUnit)(((dictMonadAff.MonadEffect0()).Monad0()).Bind1())(Effect_Aff_Class.liftAff(dictMonadAff)(Effect_Aff_AVar.put(Data_Either.either(MFailed.create)(MMemoized.create)(res))($$var)))(function () {
                                return Data_Either.either(Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0()))(Control_Applicative.pure(((dictMonadAff.MonadEffect0()).Monad0()).Applicative0()))(res);
                            });
                        });
                    };
                    throw new Error("Failed pattern match at Test.Spec (line 316, column 31 - line 322, column 33): " + [ v.constructor.name ]);
                });
            };
        };
    };
};
var mapSpecTree = function (dictFunctor) {
    return function (g) {
        return function (f) {
            return Data_Newtype.over()()(SpecT)(Control_Monad_Writer_Trans.mapWriterT((function () {
                var $75 = Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Tuple.functorTuple)(Data_Functor.map(Data_Functor.functorArray)(f)));
                return function ($76) {
                    return $75(g($76));
                };
            })()));
        };
    };
};

// | marks all spec items of the given spec to be safe for parallel evaluation.
var parallel = function (dictMonad) {
    return mapSpecTree(((dictMonad.Bind1()).Apply0()).Functor0())(Control_Category.identity(Control_Category.categoryFn))(Data_Bifunctor.bimap(Test_Spec_Tree.treeBifunctor)(Control_Category.identity(Control_Category.categoryFn))(setParallelizable(true)));
};

// | marks all spec items of the given spec to be evaluated sequentially.
var sequential = function (dictMonad) {
    return mapSpecTree(((dictMonad.Bind1()).Apply0()).Functor0())(Control_Category.identity(Control_Category.categoryFn))(Data_Bifunctor.bimap(Test_Spec_Tree.treeBifunctor)(Control_Category.identity(Control_Category.categoryFn))(setParallelizable(false)));
};
var hoistSpec = function (dictMonad) {
    return function (onM) {
        return function (f) {
            var onTest = function (name) {
                return Data_Newtype.over()()(Test_Spec_Tree.Item)(function (item) {
                    var e = function (g) {
                        return g((function () {
                            var $77 = f(new TestWithName(name));
                            return function ($78) {
                                return $77(item.example(Data_Function.applyFlipped($78)));
                            };
                        })());
                    };
                    return {
                        example: e,
                        isFocused: item.isFocused,
                        isParallelizable: item.isParallelizable
                    };
                });
            };
            var onCleanUp = function (name) {
                return function (around$prime) {
                    return function (i) {
                        return f(new CleanUpWithContext(name))(around$prime(i));
                    };
                };
            };
            return mapSpecTree(((dictMonad.Bind1()).Apply0()).Functor0())(onM)(Test_Spec_Tree.bimapTree(onCleanUp)(onTest));
        };
    };
};
var functorSpecT = function (dictFunctor) {
    return Control_Monad_Writer_Trans.functorWriterT(dictFunctor);
};

// ---------------------
// --       DSL       --
// ---------------------
// | `focus` focuses all spec items of the given spec.
// |
// | Applying `focus` to a spec with focused spec items has no effect.
var focus = function () {
    return function (dictMonad) {
        return Data_Newtype.over()()(SpecT)(Control_Monad_Writer_Trans.mapWriterT(Data_Functor.map(((dictMonad.Bind1()).Apply0()).Functor0())(Data_Functor.map(Data_Tuple.functorTuple)(function (xs) {
            var $72 = Data_Foldable.any(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Foldable.any(Test_Spec_Tree.treeFoldable)(Data_HeytingAlgebra.heytingAlgebraBoolean)((function () {
                var $79 = Data_Newtype.un()(Test_Spec_Tree.Item);
                return function ($80) {
                    return (function (v) {
                        return v.isFocused;
                    })($79($80));
                };
            })()))(xs);
            if ($72) {
                return xs;
            };
            return Data_Functor.map(Data_Functor.functorArray)(Data_Bifunctor.bimap(Test_Spec_Tree.treeBifunctor)(Control_Category.identity(Control_Category.categoryFn))(function (v) {
                return {
                    isFocused: true,
                    isParallelizable: v.isParallelizable,
                    example: v.example
                };
            }))(xs);
        }))));
    };
};
var exampleMUnit = {
    evaluateExample: function (t) {
        return function (around$prime) {
            return around$prime(function (v) {
                return t;
            });
        };
    }
};
var exampleFunc = {
    evaluateExample: function (t) {
        return function (around$prime) {
            return around$prime(t);
        };
    }
};
var evaluateExample = function (dict) {
    return dict.evaluateExample;
};

// | Create a spec with a description.
var it = function (dictMonad) {
    return function (dictExample) {
        return function (name) {
            return function (test) {
                return Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid.monoidArray)(dictMonad))([ new Test_Spec_Tree.Leaf(name, new Data_Maybe.Just({
                    isParallelizable: Data_Maybe.Nothing.value,
                    isFocused: false,
                    example: evaluateExample(dictExample)(test)
                })) ]);
            };
        };
    };
};

// | Create a spec with a description and mark it as the only one to
// | be run. (useful for quickly narrowing down on a single test)
var itOnly = function () {
    return function (dictMonad) {
        return function (dictExample) {
            var $81 = Data_Functor.map(Data_Functor.functorFn)(focus()(dictMonad));
            var $82 = it(dictMonad)(dictExample);
            return function ($83) {
                return $81($82($83));
            };
        };
    };
};

// | Combine a group of specs into a described hierarchy.
var describe = function (dictMonad) {
    return function (name) {
        return Data_Newtype.over()()(SpecT)(Control_Monad_Writer_Trans.mapWriterT(Data_Functor.map(((dictMonad.Bind1()).Apply0()).Functor0())(Data_Functor.map(Data_Tuple.functorTuple)(function (group) {
            return [ new Test_Spec_Tree.Node(new Data_Either.Left(name), group) ];
        }))));
    };
};

// | Combine a group of specs into a described hierarchy and mark it as the
// | only group to actually be evaluated. (useful for quickly narrowing down
// | on a set)
var describeOnly = function () {
    return function (dictMonad) {
        var $84 = Data_Functor.map(Data_Functor.functorFn)(focus()(dictMonad));
        var $85 = describe(dictMonad);
        return function ($86) {
            return $84($85($86));
        };
    };
};

// | Collects all tests, if something is focused, all unfocused tests will be discarded
var collect = function (dictFunctor) {
    var $87 = Data_Functor.map(dictFunctor)(Test_Spec_Tree.discardUnfocused);
    var $88 = Control_Monad_Writer_Trans.execWriterT(dictFunctor);
    var $89 = Data_Newtype.un()(SpecT);
    return function ($90) {
        return $87($88($89($90)));
    };
};
var bindSpecT = function (dictBind) {
    return Control_Monad_Writer_Trans.bindWriterT(Data_Semigroup.semigroupArray)(dictBind);
};

// ---------------------
// --      HOOKS      --
// ---------------------
// | Run a custom action before and/or after every spec item.
var aroundWith = function (dictMonad) {
    return function (action) {
        return mapSpecTree(((dictMonad.Bind1()).Apply0()).Functor0())(Control_Category.identity(Control_Category.categoryFn))(Data_Bifunctor.bimap(Test_Spec_Tree.treeBifunctor)(action)(Test_Spec_Tree.modifyAroundAction(action)));
    };
};

// | Run a custom action before and/or after every spec item.
var around_ = function (dictMonad) {
    return function (action) {
        return aroundWith(dictMonad)(function (e) {
            return function (a) {
                return action(e(a));
            };
        });
    };
};

// | Run a custom action before every spec item.
var before_ = function (dictMonad) {
    return function (dictMonad1) {
        return function (action) {
            return around_(dictMonad)(function (v) {
                return Control_Apply.applySecond((dictMonad1.Bind1()).Apply0())(action)(v);
            });
        };
    };
};

// | Run a custom action before the first spec item.
var beforeAll_ = function (dictMonadEffect) {
    return function (dictMonadAff) {
        return function (dictMonadError) {
            return function (action) {
                return function (spec) {
                    return Control_Bind.bind(bindSpecT((dictMonadEffect.Monad0()).Bind1()))(Effect_Class.liftEffect(monadEffectWriter(dictMonadEffect))(Effect_AVar["new"](MEmpty.value)))(function ($$var) {
                        return before_(dictMonadEffect.Monad0())((dictMonadAff.MonadEffect0()).Monad0())(memoize(dictMonadAff)(dictMonadError)($$var)(action))(spec);
                    });
                };
            };
        };
    };
};

// | Run a custom action before every spec item.
var beforeWith = function (dictMonad) {
    return function (dictMonad1) {
        return function (action) {
            return aroundWith(dictMonad)(function (e) {
                return function (x) {
                    return Control_Bind.bind(dictMonad1.Bind1())(action(x))(e);
                };
            });
        };
    };
};

// | Run a custom action before and/or after every spec item.
var around = function (dictMonad) {
    return function (action) {
        return aroundWith(dictMonad)(function (e) {
            return function (v) {
                return action(e);
            };
        });
    };
};

// | Run a custom action before every spec item.
var before = function (dictMonad) {
    return function (dictMonad1) {
        return function (action) {
            return around(dictMonad)(function (v) {
                return Control_Bind.bind(dictMonad1.Bind1())(action)(v);
            });
        };
    };
};

// | Run a custom action before the first spec item.
var beforeAll = function (dictMonadEffect) {
    return function (dictMonadAff) {
        return function (dictMonadError) {
            return function (action) {
                return function (spec) {
                    return Control_Bind.bind(bindSpecT((dictMonadEffect.Monad0()).Bind1()))(Effect_Class.liftEffect(monadEffectWriter(dictMonadEffect))(Effect_AVar["new"](MEmpty.value)))(function ($$var) {
                        return before(dictMonadEffect.Monad0())((dictMonadAff.MonadEffect0()).Monad0())(memoize(dictMonadAff)(dictMonadError)($$var)(action))(spec);
                    });
                };
            };
        };
    };
};
var applySpecT = function (dictApply) {
    return Control_Monad_Writer_Trans.applyWriterT(Data_Semigroup.semigroupArray)(dictApply);
};
var applicativeSpecT = function (dictApplicative) {
    return Control_Monad_Writer_Trans.applicativeWriterT(Data_Monoid.monoidArray)(dictApplicative);
};
var alternativeSpecT = function (dictAlternative) {
    return Control_Monad_Writer_Trans.alternativeWriterT(Data_Monoid.monoidArray)(dictAlternative);
};
var altSpecT = function (dictAlt) {
    return Control_Monad_Writer_Trans.altWriterT(dictAlt);
};

// | Run a custom action after the last spec item.
var afterAll = function (dictMonad) {
    return function (action) {
        return Data_Newtype.over()()(SpecT)(Control_Monad_Writer_Trans.mapWriterT(Data_Functor.map(((dictMonad.Bind1()).Apply0()).Functor0())(Data_Functor.map(Data_Tuple.functorTuple)(function (group) {
            return [ new Test_Spec_Tree.Node(new Data_Either.Right(action), group) ];
        }))));
    };
};

// | Run a custom action after the last spec item.
var afterAll_ = function (dictMonad) {
    return function (action) {
        return afterAll(dictMonad)(Data_Function["const"](action));
    };
};

// | Run a custom action after every spec item.
var after = function (dictMonad) {
    return function (dictMonadBracket) {
        return function (action) {
            var $$finally = function (act) {
                return function (fin) {
                    return Control_Monad_Fork_Class.bracket(dictMonadBracket)(Control_Applicative.pure((((dictMonadBracket.MonadError1()).MonadThrow0()).Monad0()).Applicative0())(Data_Unit.unit))(function (v) {
                        return function (v1) {
                            return fin;
                        };
                    })(Data_Function["const"](act));
                };
            };
            return aroundWith(dictMonad)(function (e) {
                return function (x) {
                    return $$finally(e(x))(action(x));
                };
            });
        };
    };
};

// | Run a custom action after every spec item.
var after_ = function (dictMonad) {
    return function (dictMonadBracket) {
        return function (action) {
            return after(dictMonad)(dictMonadBracket)(function (v) {
                return action;
            });
        };
    };
};
module.exports = {
    SpecT: SpecT,
    mapSpecTree: mapSpecTree,
    collect: collect,
    CleanUpWithContext: CleanUpWithContext,
    TestWithName: TestWithName,
    hoistSpec: hoistSpec,
    evaluateExample: evaluateExample,
    parallel: parallel,
    sequential: sequential,
    focus: focus,
    describeOnly: describeOnly,
    itOnly: itOnly,
    describe: describe,
    it: it,
    pending: pending,
    "pending'": pending$prime,
    aroundWith: aroundWith,
    around: around,
    around_: around_,
    before: before,
    before_: before_,
    beforeWith: beforeWith,
    beforeAll: beforeAll,
    beforeAll_: beforeAll_,
    after: after,
    after_: after_,
    afterAll: afterAll,
    afterAll_: afterAll_,
    newtypeSpecT: newtypeSpecT,
    functorSpecT: functorSpecT,
    applySpecT: applySpecT,
    applicativeSpecT: applicativeSpecT,
    altSpecT: altSpecT,
    plusSpecT: plusSpecT,
    alternativeSpecT: alternativeSpecT,
    bindSpecT: bindSpecT,
    monadSpecT: monadSpecT,
    monadRecSpecT: monadRecSpecT,
    monadZeroSpecT: monadZeroSpecT,
    monadPlusSpecT: monadPlusSpecT,
    monadTransSpecT: monadTransSpecT,
    monadEffectWriter: monadEffectWriter,
    monadContSpecT: monadContSpecT,
    monadThrowSpecT: monadThrowSpecT,
    monadErrorSpecT: monadErrorSpecT,
    monadAskSpecT: monadAskSpecT,
    monadReaderSpecT: monadReaderSpecT,
    monadStateSpecT: monadStateSpecT,
    exampleFunc: exampleFunc,
    exampleMUnit: exampleMUnit,
    warn: warn,
    Item: Test_Spec_Tree.Item,
    Leaf: Test_Spec_Tree.Leaf,
    Node: Test_Spec_Tree.Node
};
