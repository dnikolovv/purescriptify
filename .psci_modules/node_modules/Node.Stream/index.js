
// | This module provides a low-level wrapper for the [Node Stream API](https://nodejs.org/api/stream.html).
"use strict";
var $foreign = require("./foreign.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Show = require("../Data.Show/index.js");
var Effect = require("../Effect/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Node_Buffer = require("../Node.Buffer/index.js");
var Node_Buffer_Class = require("../Node.Buffer.Class/index.js");
var Node_Encoding = require("../Node.Encoding/index.js");

// | Write a string in the specified encoding to a writable stream.
var writeString = function (w) {
    return function (enc) {
        return $foreign.writeStringImpl(w)(Data_Show.show(Node_Encoding.showEncoding)(enc));
    };
};

// | Set the encoding used to read chunks as strings from the stream. This
// | function may be useful when you are passing a readable stream to some other
// | JavaScript library, which already expects an encoding to be set.
// |
// | Where possible, you should try to use `onDataString` instead of this
// | function.
var setEncoding = function (r) {
    return function (enc) {
        return $foreign.setEncodingImpl(r)(Data_Show.show(Node_Encoding.showEncoding)(enc));
    };
};

// | Set the default encoding used to write strings to the stream. This function
// | is useful when you are passing a writable stream to some other JavaScript
// | library, which already expects a default encoding to be set. It has no
// | effect on the behaviour of the `writeString` function (because that
// | function ensures that the encoding is always supplied explicitly).
var setDefaultEncoding = function (r) {
    return function (enc) {
        return $foreign.setDefaultEncodingImpl(r)(Data_Show.show(Node_Encoding.showEncoding)(enc));
    };
};
var readChunk = $foreign.readChunkImpl(Data_Either.Left.create)(Data_Either.Right.create);
var readEither = function (r) {
    return function (size) {
        return $foreign.readImpl(readChunk)(Data_Maybe.Nothing.value)(Data_Maybe.Just.create)(r)(Data_Maybe.fromMaybe($foreign["undefined"])(size));
    };
};
var readString = function (r) {
    return function (size) {
        return function (enc) {
            return function __do() {
                var v = readEither(r)(size)();
                if (v instanceof Data_Maybe.Nothing) {
                    return Data_Maybe.Nothing.value;
                };
                if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Either.Left) {
                    return Effect_Exception["throw"]("Stream encoding should not be set")();
                };
                if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Either.Right) {
                    return Data_Functor.map(Effect.functorEffect)(Data_Maybe.Just.create)(Node_Buffer_Class.toString(Node_Buffer.mutableBufferEffect)(enc)(v.value0.value0))();
                };
                throw new Error("Failed pattern match at Node.Stream (line 120, column 3 - line 123, column 60): " + [ v.constructor.name ]);
            };
        };
    };
};
var read = function (r) {
    return function (size) {
        return function __do() {
            var v = readEither(r)(size)();
            if (v instanceof Data_Maybe.Nothing) {
                return Data_Maybe.Nothing.value;
            };
            if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Either.Left) {
                return Effect_Exception["throw"]("Stream encoding should not be set")();
            };
            if (v instanceof Data_Maybe.Just && v.value0 instanceof Data_Either.Right) {
                return new Data_Maybe.Just(v.value0.value0);
            };
            throw new Error("Failed pattern match at Node.Stream (line 107, column 3 - line 110, column 36): " + [ v.constructor.name ]);
        };
    };
};

// | Listen for `data` events, returning data in an `Either String Buffer`. This
// | function is provided for the (hopefully rare) case that `setEncoding` has
// | been called on the stream.
var onDataEither = function (r) {
    return function (cb) {
        return $foreign.onDataEitherImpl(readChunk)(r)(cb);
    };
};

// | Listen for `data` events, returning data in a Buffer. Note that this will fail
// | if `setEncoding` has been called on the stream.
var onData = function (r) {
    return function (cb) {
        var fromEither = function (x) {
            if (x instanceof Data_Either.Left) {
                return Effect_Exception["throw"]("Stream encoding should not be set");
            };
            if (x instanceof Data_Either.Right) {
                return Control_Applicative.pure(Effect.applicativeEffect)(x.value0);
            };
            throw new Error("Failed pattern match at Node.Stream (line 94, column 5 - line 98, column 17): " + [ x.constructor.name ]);
        };
        return onDataEither(r)(Control_Bind.composeKleisliFlipped(Effect.bindEffect)(cb)(fromEither));
    };
};

// | Listen for `data` events, returning data in a String, which will be
// | decoded using the given encoding. Note that this will fail if `setEncoding`
// | has been called on the stream.
var onDataString = function (r) {
    return function (enc) {
        return function (cb) {
            return onData(r)(Control_Bind.composeKleisliFlipped(Effect.bindEffect)(cb)(Node_Buffer_Class.toString(Node_Buffer.mutableBufferEffect)(enc)));
        };
    };
};
module.exports = {
    onData: onData,
    onDataString: onDataString,
    onDataEither: onDataEither,
    setEncoding: setEncoding,
    read: read,
    readString: readString,
    readEither: readEither,
    writeString: writeString,
    setDefaultEncoding: setDefaultEncoding,
    onReadable: $foreign.onReadable,
    onEnd: $foreign.onEnd,
    onFinish: $foreign.onFinish,
    onClose: $foreign.onClose,
    onError: $foreign.onError,
    resume: $foreign.resume,
    pause: $foreign.pause,
    isPaused: $foreign.isPaused,
    pipe: $foreign.pipe,
    unpipe: $foreign.unpipe,
    unpipeAll: $foreign.unpipeAll,
    write: $foreign.write,
    cork: $foreign.cork,
    uncork: $foreign.uncork,
    end: $foreign.end,
    destroy: $foreign.destroy
};
