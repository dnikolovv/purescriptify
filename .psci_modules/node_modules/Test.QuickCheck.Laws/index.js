"use strict";
var Data_Bounded = require("../Data.Bounded/index.js");
var Data_Enum = require("../Data.Enum/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Effect_Console = require("../Effect.Console/index.js");
var Test_QuickCheck_Arbitrary = require("../Test.QuickCheck.Arbitrary/index.js");
var E = function (x) {
    return x;
};
var D = function (x) {
    return x;
};
var C = function (x) {
    return x;
};
var B = function (x) {
    return x;
};
var A = function (x) {
    return x;
};
var semigroupE = Data_Ordering.semigroupOrdering;
var semigroupD = Data_Ordering.semigroupOrdering;
var semigroupC = Data_Ordering.semigroupOrdering;
var semigroupB = Data_Ordering.semigroupOrdering;
var semigroupA = Data_Ordering.semigroupOrdering;
var ordE = Data_Ord.ordOrdering;
var ordD = Data_Ord.ordOrdering;
var ordC = Data_Ord.ordOrdering;
var ordB = Data_Ord.ordOrdering;
var ordA = Data_Ord.ordOrdering;
var monoidE = {
    mempty: Data_Ordering.EQ.value,
    Semigroup0: function () {
        return semigroupE;
    }
};
var monoidD = {
    mempty: Data_Ordering.EQ.value,
    Semigroup0: function () {
        return semigroupD;
    }
};
var monoidC = {
    mempty: Data_Ordering.EQ.value,
    Semigroup0: function () {
        return semigroupC;
    }
};
var monoidB = {
    mempty: Data_Ordering.EQ.value,
    Semigroup0: function () {
        return semigroupB;
    }
};
var monoidA = {
    mempty: Data_Ordering.EQ.value,
    Semigroup0: function () {
        return semigroupA;
    }
};
var eqE = Data_Ordering.eqOrdering;
var eqD = Data_Ordering.eqOrdering;
var eqC = Data_Ordering.eqOrdering;
var eqB = Data_Ordering.eqOrdering;
var eqA = Data_Ordering.eqOrdering;
var enumE = Data_Enum.enumOrdering;
var enumD = Data_Enum.enumOrdering;
var enumC = Data_Enum.enumOrdering;
var enumB = Data_Enum.enumOrdering;
var enumA = Data_Enum.enumOrdering;
var coarbitraryE = Test_QuickCheck_Arbitrary.coarbOrdering;
var coarbitraryD = Test_QuickCheck_Arbitrary.coarbOrdering;
var coarbitraryC = Test_QuickCheck_Arbitrary.coarbOrdering;
var coarbitraryB = Test_QuickCheck_Arbitrary.coarbOrdering;
var coarbitraryA = Test_QuickCheck_Arbitrary.coarbOrdering;
var checkLaws = function (typeName) {
    return function (laws) {
        return function __do() {
            Effect_Console.log("\x0a\x0aChecking laws of " + (typeName + " instances...\x0a"))();
            return laws();
        };
    };
};
var boundedEnumE = Data_Enum.boundedEnumOrdering;
var boundedEnumD = Data_Enum.boundedEnumOrdering;
var boundedEnumC = Data_Enum.boundedEnumOrdering;
var boundedEnumB = Data_Enum.boundedEnumOrdering;
var boundedEnumA = Data_Enum.boundedEnumOrdering;
var boundedE = Data_Bounded.boundedOrdering;
var boundedD = Data_Bounded.boundedOrdering;
var boundedC = Data_Bounded.boundedOrdering;
var boundedB = Data_Bounded.boundedOrdering;
var boundedA = Data_Bounded.boundedOrdering;
var arbitraryE = Test_QuickCheck_Arbitrary.arbOrdering;
var arbitraryD = Test_QuickCheck_Arbitrary.arbOrdering;
var arbitraryC = Test_QuickCheck_Arbitrary.arbOrdering;
var arbitraryB = Test_QuickCheck_Arbitrary.arbOrdering;
var arbitraryA = Test_QuickCheck_Arbitrary.arbOrdering;
module.exports = {
    A: A,
    B: B,
    C: C,
    D: D,
    E: E,
    checkLaws: checkLaws,
    arbitraryA: arbitraryA,
    boundedA: boundedA,
    enumA: enumA,
    boundedEnumA: boundedEnumA,
    coarbitraryA: coarbitraryA,
    eqA: eqA,
    ordA: ordA,
    semigroupA: semigroupA,
    monoidA: monoidA,
    arbitraryB: arbitraryB,
    boundedB: boundedB,
    enumB: enumB,
    boundedEnumB: boundedEnumB,
    coarbitraryB: coarbitraryB,
    eqB: eqB,
    ordB: ordB,
    semigroupB: semigroupB,
    monoidB: monoidB,
    arbitraryC: arbitraryC,
    boundedC: boundedC,
    enumC: enumC,
    boundedEnumC: boundedEnumC,
    coarbitraryC: coarbitraryC,
    eqC: eqC,
    ordC: ordC,
    semigroupC: semigroupC,
    monoidC: monoidC,
    arbitraryD: arbitraryD,
    boundedD: boundedD,
    enumD: enumD,
    boundedEnumD: boundedEnumD,
    coarbitraryD: coarbitraryD,
    eqD: eqD,
    ordD: ordD,
    semigroupD: semigroupD,
    monoidD: monoidD,
    arbitraryE: arbitraryE,
    boundedE: boundedE,
    enumE: enumE,
    boundedEnumE: boundedEnumE,
    coarbitraryE: coarbitraryE,
    eqE: eqE,
    ordE: ordE,
    semigroupE: semigroupE,
    monoidE: monoidE
};
