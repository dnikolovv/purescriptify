
// | This module is a partial port of the Haskell QuickCheck library.
// |
// | QuickCheck provides a way to write _property-based_ tests.
// |
// | The `Arbitrary` and `CoArbitrary` type classes allow us to create
// | random data with which we can run our tests. This module provides
// | instances of both classes for PureScript's core data structures,
// | as well as functions for writing new instances.
// |
// | Test suites can use the `quickCheck` and `quickCheckPure` functions
// | to test properties.
// |
// | For example:
// |
// | ```purescript
// | main = quickCheck \n -> n + 1 > n
// | ```
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Maybe_First = require("../Data.Maybe.First/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Effect = require("../Effect/index.js");
var Effect_Console = require("../Effect.Console/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Random_LCG = require("../Random.LCG/index.js");
var Test_QuickCheck_Arbitrary = require("../Test.QuickCheck.Arbitrary/index.js");
var Test_QuickCheck_Gen = require("../Test.QuickCheck.Gen/index.js");

// | The result of a test: success or failure (with an error message).
var Success = (function () {
    function Success() {

    };
    Success.value = new Success();
    return Success;
})();

// | The result of a test: success or failure (with an error message).
var Failed = (function () {
    function Failed(value0) {
        this.value0 = value0;
    };
    Failed.create = function (value0) {
        return new Failed(value0);
    };
    return Failed;
})();

// | This operator attaches an error message to a failed test.
// |
// | For example:
// |
// | ```purescript
// | test x = myProperty x <?> ("myProperty did not hold for " <> show x)
// | ```
var withHelp = function (v) {
    return function (v1) {
        if (v) {
            return Success.value;
        };
        if (!v) {
            return new Failed(v1);
        };
        throw new Error("Failed pattern match at Test.QuickCheck (line 233, column 1 - line 233, column 40): " + [ v.constructor.name, v1.constructor.name ]);
    };
};
var testableResult = {
    test: Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)
};
var testableBoolean = {
    test: function (v) {
        if (v) {
            return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Success.value);
        };
        if (!v) {
            return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(new Failed("Test returned false"));
        };
        throw new Error("Failed pattern match at Test.QuickCheck (line 209, column 1 - line 211, column 51): " + [ v.constructor.name ]);
    }
};
var test = function (dict) {
    return dict.test;
};
var testableFunction = function (dictArbitrary) {
    return function (dictTestable) {
        return {
            test: function (f) {
                return Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(Test_QuickCheck_Arbitrary.arbitrary(dictArbitrary))((function () {
                    var $66 = test(dictTestable);
                    return function ($67) {
                        return $66(f($67));
                    };
                })());
            }
        };
    };
};
var testableGen = function (dictTestable) {
    return {
        test: Data_Function.flip(Control_Bind.bind(Test_QuickCheck_Gen.bindGen))(test(dictTestable))
    };
};
var showResult = {
    show: function (v) {
        if (v instanceof Success) {
            return "Success";
        };
        if (v instanceof Failed) {
            return "Failed: " + v.value0;
        };
        throw new Error("Failed pattern match at Test.QuickCheck (line 222, column 1 - line 224, column 40): " + [ v.constructor.name ]);
    }
};

// | A variant of the `quickCheck'` function that accepts a specific seed as
// | well as the number tests that should be run.
var quickCheckWithSeed = function (dictTestable) {
    return function (initialSeed) {
        return function (n) {
            return function (prop) {
                var loop = function (v) {
                    if (v.index === n) {
                        return new Control_Monad_Rec_Class.Done(v);
                    };
                    if (Data_Boolean.otherwise) {
                        var v1 = Test_QuickCheck_Gen.runGen(test(dictTestable)(prop))({
                            newSeed: v.seed,
                            size: 10
                        });
                        if (v1.value0 instanceof Success) {
                            return new Control_Monad_Rec_Class.Loop({
                                seed: v1.value1.newSeed,
                                index: v.index + 1 | 0,
                                successes: v.successes + 1 | 0,
                                firstFailure: v.firstFailure
                            });
                        };
                        if (v1.value0 instanceof Failed) {
                            return new Control_Monad_Rec_Class.Loop({
                                seed: v1.value1.newSeed,
                                index: v.index + 1 | 0,
                                successes: v.successes,
                                firstFailure: Data_Semigroup.append(Data_Maybe_First.semigroupFirst)(v.firstFailure)(new Data_Maybe.Just({
                                    index: v.index,
                                    message: v1.value0.value0,
                                    seed: v.seed
                                }))
                            });
                        };
                        throw new Error("Failed pattern match at Test.QuickCheck (line 119, column 9 - line 134, column 16): " + [ v1.constructor.name ]);
                    };
                    throw new Error("Failed pattern match at Test.QuickCheck (line 115, column 3 - line 115, column 48): " + [ v.constructor.name ]);
                };
                var result = Control_Monad_Rec_Class.tailRec(loop)({
                    seed: initialSeed,
                    index: 0,
                    successes: 0,
                    firstFailure: Data_Monoid.mempty(Data_Maybe_First.monoidFirst)
                });
                return function __do() {
                    Effect_Console.log(Data_Show.show(Data_Show.showInt)(result.successes) + ("/" + (Data_Show.show(Data_Show.showInt)(n) + " test(s) passed.")))();
                    return Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableFirst)(result.firstFailure)(function (v) {
                        return Effect_Exception.throwException(Effect_Exception.error("Test " + (Data_Show.show(Data_Show.showInt)(v.index + 1 | 0) + (" (seed " + (Data_Show.show(Data_Show.showInt)(Random_LCG.unSeed(v.seed)) + (") failed: \x0a" + v.message))))));
                    })();
                };
            };
        };
    };
};

// | Test a property, returning all test results as a List, with the Seed that
// | was used for each result.
// |
// | The first argument is the _random seed_ to be passed to the random generator.
// | The second argument is the number of tests to run.
var quickCheckPure$prime = function (dictTestable) {
    return function (s) {
        return function (n) {
            return function (prop) {
                var go = function (p) {
                    return Test_QuickCheck_Gen.stateful(function (gs) {
                        return Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Tuple.Tuple.create(gs.newSeed))(test(dictTestable)(p));
                    });
                };
                return Test_QuickCheck_Gen.evalGen(Data_Unfoldable.replicateA(Test_QuickCheck_Gen.applicativeGen)(Data_List_Types.unfoldableList)(Data_List_Types.traversableList)(n)(go(prop)))({
                    newSeed: s,
                    size: 10
                });
            };
        };
    };
};

// | Test a property, returning all test results as a List.
// |
// | The first argument is the _random seed_ to be passed to the random generator.
// | The second argument is the number of tests to run.
var quickCheckPure = function (dictTestable) {
    return function (s) {
        return function (n) {
            return function (prop) {
                return Test_QuickCheck_Gen.evalGen(Data_Unfoldable.replicateA(Test_QuickCheck_Gen.applicativeGen)(Data_List_Types.unfoldableList)(Data_List_Types.traversableList)(n)(test(dictTestable)(prop)))({
                    newSeed: s,
                    size: 10
                });
            };
        };
    };
};

// | A version of `quickCheckWithSeed` with the property specialized to `Gen`.
var quickCheckGenWithSeed = function (dictTestable) {
    return quickCheckWithSeed(testableGen(dictTestable));
};

// | A version of `quickCheckPure'` with the property specialized to `Gen`.
var quickCheckGenPure$prime = function (dictTestable) {
    return quickCheckPure$prime(testableGen(dictTestable));
};

// | A version of `quickCheckPure` with the property specialized to `Gen`.
var quickCheckGenPure = function (dictTestable) {
    return quickCheckPure(testableGen(dictTestable));
};

// | A variant of the `quickCheck` function which accepts an extra parameter
// | representing the number of tests which should be run.
var quickCheck$prime = function (dictTestable) {
    return function (n) {
        return function (prop) {
            return function __do() {
                var seed = Random_LCG.randomSeed();
                return quickCheckWithSeed(dictTestable)(seed)(n)(prop)();
            };
        };
    };
};

// | A version of `quickCheck'` with the property specialized to `Gen`.
var quickCheckGen$prime = function (dictTestable) {
    return quickCheck$prime(testableGen(dictTestable));
};

// | Test a property.
// |
// | This function generates a new random seed, runs 100 tests and
// | prints the test results to the console.
var quickCheck = function (dictTestable) {
    return function (prop) {
        return quickCheck$prime(dictTestable)(100)(prop);
    };
};

// | A version of `quickCheck` with the property specialized to `Gen`.
// |
// | The `quickCheckGen` variants are useful for writing property tests where a
// | `MonadGen` constraint (or QuickCheck's `Gen` directly) is being used,
// | rather than relying on `Arbitrary` instances. Especially useful for the
// | `MonadGen`-constrained properties as they will not infer correctly when
// | used with the `quickCheck` functions unless an explicit type annotation is
// | used.
var quickCheckGen = function (dictTestable) {
    return quickCheck(testableGen(dictTestable));
};

// | Print a one-line summary in the form "x/y test(s) passed."
var printSummary = function (summary) {
    return Data_Show.show(Data_Show.showInt)(summary.successes) + ("/" + (Data_Show.show(Data_Show.showInt)(summary.total) + (function () {
        var $58 = summary.total === 1;
        if ($58) {
            return " test passed.";
        };
        return " tests passed.";
    })()));
};

// | Processes the results from `quickCheckPure'` to produce a `ResultSummary`.
var checkResults = (function () {
    var go = function (index) {
        return function (st) {
            return function (v) {
                if (v.value1 instanceof Success) {
                    return {
                        total: st.total + 1 | 0,
                        successes: st.successes + 1 | 0,
                        failures: st.failures
                    };
                };
                if (v.value1 instanceof Failed) {
                    return {
                        total: st.total + 1 | 0,
                        successes: st.successes,
                        failures: new Data_List_Types.Cons({
                            index: index,
                            seed: v.value0,
                            message: v.value1.value0
                        }, st.failures)
                    };
                };
                throw new Error("Failed pattern match at Test.QuickCheck (line 185, column 7 - line 189, column 97): " + [ v.value1.constructor.name ]);
            };
        };
    };
    return Data_FoldableWithIndex.foldlWithIndex(Data_List_Types.foldableWithIndexList)(go)({
        total: 0,
        successes: 0,
        failures: Data_List_Types.Nil.value
    });
})();

// | Self-documenting comparison operation
var assertOp = function (dictEq) {
    return function (dictShow) {
        return function (op) {
            return function (failString) {
                return function (a) {
                    return function (b) {
                        return withHelp(op(a)(b))(Data_Show.show(dictShow)(a) + (failString + Data_Show.show(dictShow)(b)));
                    };
                };
            };
        };
    };
};

// | Self-documenting inequality assertion
var assertNotEquals = function (dictEq) {
    return function (dictShow) {
        return assertOp(dictEq)(dictShow)(Data_Eq.notEq(dictEq))(" == ");
    };
};
var assertLessThanEq = function (dictOrd) {
    return function (dictShow) {
        return assertOp(dictOrd.Eq0())(dictShow)(Data_Ord.lessThanOrEq(dictOrd))(" > ");
    };
};
var assertLessThan = function (dictOrd) {
    return function (dictShow) {
        return assertOp(dictOrd.Eq0())(dictShow)(Data_Ord.lessThan(dictOrd))(" >= ");
    };
};
var assertGreaterThanEq = function (dictOrd) {
    return function (dictShow) {
        return assertOp(dictOrd.Eq0())(dictShow)(Data_Ord.greaterThanOrEq(dictOrd))(" < ");
    };
};
var assertGreaterThan = function (dictOrd) {
    return function (dictShow) {
        return assertOp(dictOrd.Eq0())(dictShow)(Data_Ord.greaterThan(dictOrd))(" <= ");
    };
};

// | Self-documenting equality assertion
var assertEquals = function (dictEq) {
    return function (dictShow) {
        return assertOp(dictEq)(dictShow)(Data_Eq.eq(dictEq))(" /= ");
    };
};
module.exports = {
    quickCheck: quickCheck,
    quickCheckGen: quickCheckGen,
    "quickCheck'": quickCheck$prime,
    "quickCheckGen'": quickCheckGen$prime,
    quickCheckWithSeed: quickCheckWithSeed,
    quickCheckGenWithSeed: quickCheckGenWithSeed,
    quickCheckPure: quickCheckPure,
    "quickCheckPure'": quickCheckPure$prime,
    quickCheckGenPure: quickCheckGenPure,
    "quickCheckGenPure'": quickCheckGenPure$prime,
    checkResults: checkResults,
    printSummary: printSummary,
    test: test,
    Success: Success,
    Failed: Failed,
    withHelp: withHelp,
    assertEquals: assertEquals,
    assertNotEquals: assertNotEquals,
    assertLessThan: assertLessThan,
    assertLessThanEq: assertLessThanEq,
    assertGreaterThan: assertGreaterThan,
    assertGreaterThanEq: assertGreaterThanEq,
    testableResult: testableResult,
    testableBoolean: testableBoolean,
    testableFunction: testableFunction,
    testableGen: testableGen,
    showResult: showResult,
    mkSeed: Random_LCG.mkSeed,
    randomSeed: Random_LCG.randomSeed,
    unSeed: Random_LCG.unSeed,
    arbitrary: Test_QuickCheck_Arbitrary.arbitrary,
    coarbitrary: Test_QuickCheck_Arbitrary.coarbitrary
};
