
// | This module is a port of the Haskell
// | [__Text.Parsec.Language__](https://hackage.haskell.org/package/parsec/docs/Text-Parsec-Language.html)
// | module.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");
var Text_Parsing_Parser_String_Basic = require("../Text.Parsing.Parser.String.Basic/index.js");
var Text_Parsing_Parser_Token = require("../Text.Parsing.Parser.Token/index.js");

//---------------------------------------------------------
// minimal language definition
//------------------------------------------------------
// | This is the most minimal token definition. It is recommended to use
// | this definition as the basis for other definitions. `emptyDef` has
// | no reserved names or operators, is case sensitive and doesn't accept
// | comments, identifiers or operators.
var emptyDef = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    return {
        commentStart: "",
        commentEnd: "",
        commentLine: "",
        nestedComments: true,
        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String_Basic.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("_")),
        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String_Basic.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ])),
        opStart: op$prime(Data_Identity.monadIdentity),
        opLetter: op$prime(Data_Identity.monadIdentity),
        reservedOpNames: [  ],
        reservedNames: [  ],
        caseSensitive: true
    };
})();

//---------------------------------------------------------
// Styles: haskellStyle, javaStyle
//---------------------------------------------------------
// | This is a minimal token definition for Haskell style languages. It
// | defines the style of comments, valid identifiers and case
// | sensitivity. It does not define any reserved words or operators.
var haskellStyle = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    var v = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);
    return {
        commentStart: "{-",
        commentEnd: "-}",
        commentLine: "--",
        nestedComments: true,
        identStart: Text_Parsing_Parser_String_Basic.letter(Data_Identity.monadIdentity),
        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String_Basic.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ])),
        opStart: op$prime(Data_Identity.monadIdentity),
        opLetter: op$prime(Data_Identity.monadIdentity),
        reservedNames: [  ],
        reservedOpNames: [  ],
        caseSensitive: true
    };
})();

// | The language definition for the language Haskell98.
var haskell98Def = (function () {
    var v = Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle);
    return {
        commentStart: v.commentStart,
        commentEnd: v.commentEnd,
        commentLine: v.commentLine,
        nestedComments: v.nestedComments,
        identStart: v.identStart,
        identLetter: v.identLetter,
        opStart: v.opStart,
        opLetter: v.opLetter,
        reservedNames: [ "let", "in", "case", "of", "if", "then", "else", "data", "type", "class", "default", "deriving", "do", "import", "infix", "infixl", "infixr", "instance", "module", "newtype", "where", "primitive" ],
        reservedOpNames: [ "::", "..", "=", "\\", "|", "<-", "->", "@", "~", "=>" ],
        caseSensitive: v.caseSensitive
    };
})();

// | The language definition for the Haskell language.
var haskellDef = {
    commentStart: haskell98Def.commentStart,
    commentEnd: haskell98Def.commentEnd,
    commentLine: haskell98Def.commentLine,
    nestedComments: haskell98Def.nestedComments,
    identStart: haskell98Def.identStart,
    identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(haskell98Def.identLetter)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("#")),
    opStart: haskell98Def.opStart,
    opLetter: haskell98Def.opLetter,
    reservedNames: Data_Semigroup.append(Data_Semigroup.semigroupArray)(haskell98Def.reservedNames)([ "foreign", "import", "export", "primitive", "_ccall_", "_casm_", "forall" ]),
    reservedOpNames: haskell98Def.reservedOpNames,
    caseSensitive: haskell98Def.caseSensitive
};

// -----------------------------------------------------------
// -- Haskell
// -----------------------------------------------------------
// | A lexer for the haskell language.
var haskell = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(haskellDef);

// | This is a minimal token definition for Java style languages. It
// | defines the style of comments, valid identifiers and case
// | sensitivity. It does not define any reserved words or operators.
var javaStyle = (function () {
    var v = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);
    return {
        commentStart: "/*",
        commentEnd: "*/",
        commentLine: "//",
        nestedComments: true,
        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String_Basic.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "$" ])),
        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String_Basic.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "$" ])),
        opStart: v.opStart,
        opLetter: v.opLetter,
        reservedNames: [  ],
        reservedOpNames: [  ],
        caseSensitive: false
    };
})();
module.exports = {
    haskellDef: haskellDef,
    haskell: haskell,
    emptyDef: emptyDef,
    haskellStyle: haskellStyle,
    javaStyle: javaStyle
};
