
// | This module is a port of the Haskell
// | [__Text.Parsec.Indent__](https://hackage.haskell.org/package/indents-0.3.3/docs/Text-Parsec-Indent.html)
// | module from 2016-05-07.
// |
// | A module to construct indentation aware parsers. Many programming
// | language have indentation based syntax rules e.g. python and Haskell.
// | This module exports combinators to create such parsers.
// |
// | The input source can be thought of as a list of tokens. Abstractly
// | each token occurs at a line and a column and has a width. The column
// | number of a token measures is indentation. If t1 and t2 are two tokens
// | then we say that indentation of t1 is more than t2 if the column
// | number of occurrence of t1 is greater than that of t2.
// |
// | Currently this module supports two kind of indentation based syntactic
// | structures which we now describe:
// |
// | - **Block**
// |
// |   A block of indentation /c/ is a sequence of tokens with
// |   indentation at least /c/.  Examples for a block is a where clause of
// |   Haskell with no explicit braces.
// |
// | - **Line fold**
// |
// |   A line fold starting at line /l/ and indentation /c/ is a
// |   sequence of tokens that start at line /l/ and possibly continue to
// |   subsequent lines as long as the indentation is greater than /c/. Such
// |   a sequence of lines need to be /folded/ to a single line. An example
// |   is MIME headers. Line folding based binding separation is used in
// |   Haskell as well.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad = require("../Control.Monad/index.js");
var Control_Monad_State = require("../Control.Monad.State/index.js");
var Control_Monad_State_Class = require("../Control.Monad.State.Class/index.js");
var Control_Monad_State_Trans = require("../Control.Monad.State.Trans/index.js");
var Control_Monad_Trans_Class = require("../Control.Monad.Trans.Class/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var Text_Parsing_Parser_Pos = require("../Text.Parsing.Parser.Pos/index.js");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String/index.js");

// | Data type used to optional parsing
var Opt = (function () {
    function Opt(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Opt.create = function (value0) {
        return function (value1) {
            return new Opt(value0, value1);
        };
    };
    return Opt;
})();
var symbol = function (dictMonad) {
    return function (name) {
        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(Text_Parsing_Parser_String.oneOf(dictMonad)([ " ", "\x09" ])))(Text_Parsing_Parser_String.string(dictMonad)(name));
    };
};
var sourceLine = function (v) {
    return v.line;
};
var sourceColumn = function (v) {
    return v.column;
};
var setSourceLine = function (v) {
    return function (l) {
        return {
            line: l,
            column: v.column
        };
    };
};

// | Run the result of an indentation sensitive parse
var runIndent = Data_Function.flip(Control_Monad_State.evalState)(Text_Parsing_Parser_Pos.initialPos);

// | simple helper function to avoid typ-problems with MonadState instance
var put$prime = function (p) {
    return Control_Monad_Trans_Class.lift(Text_Parsing_Parser.monadTransParserT)(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(Control_Monad_State_Class.put(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(p));
};

// | @ many1 @ should prabably be inside Text.Parsing.Parser.Combinators
var many1 = function (dictMonad) {
    return function (p) {
        return Control_Apply.lift2(Text_Parsing_Parser.applyParserT(dictMonad))(Data_List_Types.Cons.create)(p)(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(p));
    };
};

// | @ getPosition @ returns current position
// | should probably be added to Text.Parsing.Parser.Pos
var getPosition = function (dictMonad) {
    return Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {
        return v.value1;
    });
};

// | simple helper function to avoid typ-problems with MonadState instance
var get$prime = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Monad_Trans_Class.lift(Text_Parsing_Parser.monadTransParserT)(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(Control_Monad_State_Class.get(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))))(function (g) {
    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(g);
});

// | Parses using the current location for indentation reference
var withPos = function (x) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(get$prime)(function (a) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(getPosition(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (p) {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(put$prime(p))(x))(function (r) {
                return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(put$prime(a))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(r));
            });
        });
    });
};
var biAp = function (f) {
    return function (c) {
        return function (v1) {
            return function (v2) {
                return c(f(v1))(f(v2));
            };
        };
    };
};

// | Ensures the current indentation level matches that of the reference
var checkIndent = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(get$prime)(function (s) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(getPosition(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (p) {
        var $22 = biAp(sourceColumn)(Data_Eq.eq(Data_Eq.eqInt))(p)(s);
        if ($22) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Unit.unit);
        };
        return Text_Parsing_Parser.fail(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("indentation doesn't match");
    });
});

// | Parses a block of lines at the same indentation level , empty Blocks allowed
var block = function (p) {
    return withPos(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(checkIndent)(p)))(function (r) {
        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(r);
    }));
};

// | Parses a block of lines at the same indentation level
var block1 = function (p) {
    return withPos(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(many1(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(checkIndent)(p)))(function (r) {
        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(r);
    }));
};

// | Parses only when indented past the level of the reference
var indented = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(getPosition(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (pos) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(get$prime)(function (s) {
        var $23 = biAp(sourceColumn)(Data_Ord.lessThanOrEq(Data_Ord.ordInt))(pos)(s);
        if ($23) {
            return Text_Parsing_Parser.fail(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("not indented");
        };
        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(put$prime(setSourceLine(s)(sourceLine(pos))))(function () {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Unit.unit);
        });
    });
});

// | `withBlock f a p` parses `a`
// | followed by an indented block of `p`
// | combining them with `f`.
var withBlock = function (f) {
    return function (a) {
        return function (p) {
            return withPos(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(a)(function (r1) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Text_Parsing_Parser_Combinators.optionMaybe(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(indented)(block(p))))(function (r) {
                    if (r instanceof Data_Maybe.Nothing) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(f(r1)(Data_List_Types.Nil.value));
                    };
                    if (r instanceof Data_Maybe.Just) {
                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(f(r1)(r.value0));
                    };
                    throw new Error("Failed pattern match at Text.Parsing.Indent (line 119, column 3 - line 121, column 30): " + [ r.constructor.name ]);
                });
            }));
        };
    };
};

// | Like 'withBlock', but throws away initial parse result
var withBlock$prime = withBlock(Data_Function.flip(Data_Function["const"]));

// | Same as `indented`, but does not change internal state
var indented$prime = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(getPosition(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (pos) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(get$prime)(function (s) {
        var $26 = biAp(sourceColumn)(Data_Ord.lessThanOrEq(Data_Ord.ordInt))(pos)(s);
        if ($26) {
            return Text_Parsing_Parser.fail(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("not indented");
        };
        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Unit.unit);
    });
});

// | Parses only on the same line as the reference
var sameLine = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(getPosition(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(function (pos) {
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(get$prime)(function (s) {
        var $27 = biAp(sourceLine)(Data_Eq.eq(Data_Eq.eqInt))(pos)(s);
        if ($27) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Unit.unit);
        };
        return Text_Parsing_Parser.fail(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("over one line");
    });
});

// | Parses only when indented past the level of the reference or on the same line
var sameOrIndented = Control_Alt.alt(Text_Parsing_Parser.altParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(sameLine)(indented);

// | `<+/>` is to indentation sensitive parsers what `ap` is to monads
var indentAp = function (a) {
    return function (b) {
        return Control_Monad.ap(Text_Parsing_Parser.monadParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(a)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(sameOrIndented)(b));
    };
};

// | Like `<+/>` but applies the second parser many times
var indentMany = function (a) {
    return function (b) {
        return Control_Monad.ap(Text_Parsing_Parser.monadParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(a)(Data_List.many(Text_Parsing_Parser.alternativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(sameOrIndented)(b)));
    };
};

// | Like `<+/>` but doesn't apply the function to the parsed value
var indentNoAp = function (a) {
    return function (b) {
        return Control_Apply.lift2(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Data_Function["const"])(a)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(sameOrIndented)(b));
    };
};

// | Parses with surrounding angle brackets
var indentAngles = function (p) {
    return withPos(indentAp(indentNoAp(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Category.identity(Control_Category.categoryFn)))(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("<")))(indentNoAp(p)(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(">"))));
};

// | Parses with surrounding braces
var indentBraces = function (p) {
    return withPos(indentAp(indentNoAp(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Category.identity(Control_Category.categoryFn)))(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("{")))(indentNoAp(p)(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("}"))));
};

// | Parses with surrounding brackets
var indentBrackets = function (p) {
    return withPos(indentAp(indentNoAp(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Category.identity(Control_Category.categoryFn)))(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("[")))(indentNoAp(p)(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("]"))));
};

// | Parses with surrounding parentheses
var indentParens = function (p) {
    return withPos(indentAp(indentNoAp(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(Control_Category.identity(Control_Category.categoryFn)))(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))("(")))(indentNoAp(p)(symbol(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(")"))));
};

// | Like `<+/>` but applies the second parser optionally using the `Optional` datatype
var indentOp = function (a) {
    return function (v) {
        return Control_Monad.ap(Text_Parsing_Parser.monadParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(a)(Text_Parsing_Parser_Combinators.option(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity))(v.value0)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity)))(sameOrIndented)(v.value1)));
    };
};
module.exports = {
    runIndent: runIndent,
    withBlock: withBlock,
    "withBlock'": withBlock$prime,
    block: block,
    block1: block1,
    indented: indented,
    "indented'": indented$prime,
    sameLine: sameLine,
    sameOrIndented: sameOrIndented,
    checkIndent: checkIndent,
    withPos: withPos,
    indentAp: indentAp,
    indentNoAp: indentNoAp,
    indentMany: indentMany,
    indentOp: indentOp,
    indentBrackets: indentBrackets,
    indentAngles: indentAngles,
    indentBraces: indentBraces,
    indentParens: indentParens,
    Opt: Opt
};
