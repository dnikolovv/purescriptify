"use strict";
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Effect_Console = require("../Effect.Console/index.js");
var Test_QuickCheck = require("../Test.QuickCheck/index.js");
var Test_QuickCheck_Arbitrary = require("../Test.QuickCheck.Arbitrary/index.js");

// | - Integral domain: `one /= zero`, and if `a` and `b` are both nonzero then
// |   so is their product `a * b`
// | - Euclidean function `degree`:
// |   - Nonnegativity: For all nonzero `a`, `degree a >= 0`
// |   - Quotient/remainder: For all `a` and `b`, where `b` is nonzero,
// |     let `q = a / b` and ``r = a `mod` b``; then `a = q*b + r`, and also
// |     either `r = zero` or `degree r < degree b`
// | - Submultiplicative euclidean function:
// |   - For all nonzero `a` and `b`, `degree a <= degree (a * b)`
var checkEuclideanRing = function (dictEuclideanRing) {
    return function (dictArbitrary) {
        return function (dictEq) {
            return function (v) {
                var submultiplicative = function (a) {
                    return function (b) {
                        if (Data_Eq.notEq(dictEq)(a)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())) && Data_Eq.notEq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()))) {
                            return Data_EuclideanRing.degree(dictEuclideanRing)(a) <= Data_EuclideanRing.degree(dictEuclideanRing)(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(a)(b));
                        };
                        if (Data_Boolean.otherwise) {
                            return true;
                        };
                        throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 67, column 3 - line 67, column 38): " + [ a.constructor.name, b.constructor.name ]);
                    };
                };
                var quotRem = function (a) {
                    return function (b) {
                        if (Data_Eq.notEq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()))) {
                            var r = Data_EuclideanRing.mod(dictEuclideanRing)(a)(b);
                            var q = Data_EuclideanRing.div(dictEuclideanRing)(a)(b);
                            return Data_Eq.eq(dictEq)(a)(Data_Semiring.add(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(q)(b))(r)) && (Data_Eq.eq(dictEq)(r)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())) || Data_EuclideanRing.degree(dictEuclideanRing)(r) < Data_EuclideanRing.degree(dictEuclideanRing)(b));
                        };
                        if (Data_Boolean.otherwise) {
                            return true;
                        };
                        throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 56, column 3 - line 56, column 28): " + [ a.constructor.name, b.constructor.name ]);
                    };
                };
                var nonnegativeEuclideanFunc = function (a) {
                    if (Data_Eq.notEq(dictEq)(a)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()))) {
                        return Data_EuclideanRing.degree(dictEuclideanRing)(a) >= 0;
                    };
                    if (Data_Boolean.otherwise) {
                        return true;
                    };
                    throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 51, column 3 - line 51, column 41): " + [ a.constructor.name ]);
                };
                var integralDomain = function (a) {
                    return function (b) {
                        if (Data_Eq.notEq(dictEq)(a)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())) && Data_Eq.notEq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()))) {
                            return Data_Eq.notEq(dictEq)(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(a)(b))(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));
                        };
                        if (Data_Boolean.otherwise) {
                            return true;
                        };
                        throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 46, column 3 - line 46, column 35): " + [ a.constructor.name, b.constructor.name ]);
                    };
                };
                return function __do() {
                    Effect_Console.log("Checking 'Integral domain' law for EuclideanRing")();
                    Effect_Console.log("one /= zero:")();
                    Test_QuickCheck["quickCheck'"](Test_QuickCheck.testableFunction(Test_QuickCheck_Arbitrary.arbUnit)(Test_QuickCheck.testableBoolean))(1)(function (v1) {
                        return Data_Eq.notEq(dictEq)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()))(Data_Semiring.one(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));
                    })();
                    Effect_Console.log("product of nonzero elements is nonzero:")();
                    Test_QuickCheck["quickCheck'"](Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableBoolean)))(1000)(integralDomain)();
                    Effect_Console.log("Checking 'Nonnegative euclidean function' law for EuclideanRing")();
                    Test_QuickCheck["quickCheck'"](Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableBoolean))(1000)(nonnegativeEuclideanFunc)();
                    Effect_Console.log("Checking 'Quotient/remainder' law for EuclideanRing")();
                    Test_QuickCheck["quickCheck'"](Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableBoolean)))(1000)(quotRem)();
                    Effect_Console.log("Checking 'Submultiplicative euclidean function' law for EuclideanRing")();
                    return Test_QuickCheck["quickCheck'"](Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableFunction(dictArbitrary)(Test_QuickCheck.testableBoolean)))(1000)(submultiplicative)();
                };
            };
        };
    };
};
module.exports = {
    checkEuclideanRing: checkEuclideanRing
};
