"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Lazy = require("../Data.Lazy/index.js");
var Data_List_Lazy_Types = require("../Data.List.Lazy.Types/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_These = require("../Data.These/index.js");
var nil = function (dict) {
    return dict.nil;
};
var crosswalkThese = {
    crosswalk: function (dictAlignable) {
        return function (f) {
            return function (v) {
                if (v instanceof Data_These.This) {
                    return nil(dictAlignable);
                };
                if (v instanceof Data_These.That) {
                    return Data_Functor.map((dictAlignable.Align0()).Functor0())(Data_These.That.create)(f(v.value0));
                };
                if (v instanceof Data_These.Both) {
                    return Data_Functor.map((dictAlignable.Align0()).Functor0())(Data_These.Both.create(v.value0))(f(v.value1));
                };
                throw new Error("Failed pattern match at Data.Align (line 115, column 17 - line 118, column 31): " + [ v.constructor.name ]);
            };
        };
    },
    Foldable0: function () {
        return Data_These.foldableThese;
    },
    Functor1: function () {
        return Data_These.functorThese;
    }
};
var crosswalkMaybe = {
    crosswalk: function (dictAlignable) {
        return function (f) {
            return function (v) {
                if (v instanceof Data_Maybe.Nothing) {
                    return nil(dictAlignable);
                };
                if (v instanceof Data_Maybe.Just) {
                    return Data_Functor.map((dictAlignable.Align0()).Functor0())(Data_Maybe.Just.create)(f(v.value0));
                };
                throw new Error("Failed pattern match at Data.Align (line 143, column 17 - line 145, column 28): " + [ v.constructor.name ]);
            };
        };
    },
    Foldable0: function () {
        return Data_Foldable.foldableMaybe;
    },
    Functor1: function () {
        return Data_Maybe.functorMaybe;
    }
};
var crosswalk = function (dict) {
    return dict.crosswalk;
};
var alignMaybe = {
    align: function (f) {
        return function (v) {
            return function (v1) {
                if (v1 instanceof Data_Maybe.Nothing) {
                    return Data_Functor.map(Data_Maybe.functorMaybe)(function ($66) {
                        return f(Data_These.This.create($66));
                    })(v);
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return Data_Functor.map(Data_Maybe.functorMaybe)(function ($67) {
                        return f(Data_These.That.create($67));
                    })(v1);
                };
                if (v instanceof Data_Maybe.Just && v1 instanceof Data_Maybe.Just) {
                    return new Data_Maybe.Just(f(new Data_These.Both(v.value0, v1.value0)));
                };
                throw new Error("Failed pattern match at Data.Align (line 52, column 1 - line 55, column 50): " + [ f.constructor.name, v.constructor.name, v1.constructor.name ]);
            };
        };
    },
    Functor0: function () {
        return Data_Maybe.functorMaybe;
    }
};
var alignableMaybe = {
    nil: Data_Maybe.Nothing.value,
    Align0: function () {
        return alignMaybe;
    }
};
var align = function (dict) {
    return dict.align;
};
var alignArray = {
    align: function (f) {
        return function (v) {
            return function (v1) {
                if (v1.length === 0) {
                    return Data_Functor.map(Data_Functor.functorArray)(function ($68) {
                        return f(Data_These.This.create($68));
                    })(v);
                };
                if (v.length === 0) {
                    return Data_Functor.map(Data_Functor.functorArray)(function ($69) {
                        return f(Data_These.That.create($69));
                    })(v1);
                };
                var ys$prime = Data_Array.drop(Data_Array.length(v))(v1);
                var xs$prime = Data_Array.drop(Data_Array.length(v1))(v);
                var f$prime = function (x) {
                    return function (y) {
                        return f(new Data_These.Both(x, y));
                    };
                };
                return Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Array.zipWith(f$prime)(v)(v1))(align(alignArray)(f)(xs$prime)(ys$prime));
            };
        };
    },
    Functor0: function () {
        return Data_Functor.functorArray;
    }
};
var alignableArray = {
    nil: Data_Monoid.mempty(Data_Monoid.monoidArray),
    Align0: function () {
        return alignArray;
    }
};
var alignLazyList = {
    align: function (f) {
        return function (xs) {
            return function (ys) {
                var go = function (v) {
                    return function (v1) {
                        if (v instanceof Data_List_Lazy_Types.Nil && v1 instanceof Data_List_Lazy_Types.Nil) {
                            return Data_List_Lazy_Types.Nil.value;
                        };
                        if (v instanceof Data_List_Lazy_Types.Cons && v1 instanceof Data_List_Lazy_Types.Nil) {
                            return new Data_List_Lazy_Types.Cons(f(new Data_These.This(v.value0)), align(alignLazyList)(f)(v.value1)(Data_Monoid.mempty(Data_List_Lazy_Types.monoidList)));
                        };
                        if (v instanceof Data_List_Lazy_Types.Nil && v1 instanceof Data_List_Lazy_Types.Cons) {
                            return new Data_List_Lazy_Types.Cons(f(new Data_These.That(v1.value0)), align(alignLazyList)(f)(Data_Monoid.mempty(Data_List_Lazy_Types.monoidList))(v1.value1));
                        };
                        if (v instanceof Data_List_Lazy_Types.Cons && v1 instanceof Data_List_Lazy_Types.Cons) {
                            return new Data_List_Lazy_Types.Cons(f(new Data_These.Both(v.value0, v1.value0)), align(alignLazyList)(f)(v.value1)(v1.value1));
                        };
                        throw new Error("Failed pattern match at Data.Align (line 47, column 7 - line 47, column 50): " + [ v.constructor.name, v1.constructor.name ]);
                    };
                };
                return Control_Apply.apply(Data_Lazy.applyLazy)(Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs)))(Data_Newtype.unwrap()(ys));
            };
        };
    },
    Functor0: function () {
        return Data_List_Lazy_Types.functorList;
    }
};
var alignableLazyList = {
    nil: Data_Monoid.mempty(Data_List_Lazy_Types.monoidList),
    Align0: function () {
        return alignLazyList;
    }
};
var alignList = {
    align: function (f) {
        return function (v) {
            return function (v1) {
                if (v1 instanceof Data_List_Types.Nil) {
                    return Data_Functor.map(Data_List_Types.functorList)(function ($70) {
                        return f(Data_These.This.create($70));
                    })(v);
                };
                if (v instanceof Data_List_Types.Nil) {
                    return Data_Functor.map(Data_List_Types.functorList)(function ($71) {
                        return f(Data_These.That.create($71));
                    })(v1);
                };
                if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {
                    return new Data_List_Types.Cons(f(new Data_These.Both(v.value0, v1.value0)), align(alignList)(f)(v.value1)(v1.value1));
                };
                throw new Error("Failed pattern match at Data.Align (line 39, column 1 - line 42, column 85): " + [ f.constructor.name, v.constructor.name, v1.constructor.name ]);
            };
        };
    },
    Functor0: function () {
        return Data_List_Types.functorList;
    }
};
var alignableList = {
    nil: Data_Monoid.mempty(Data_List_Types.monoidList),
    Align0: function () {
        return alignList;
    }
};

// | Convenience combinator for `align identity`.
var aligned = function (dictAlign) {
    return align(dictAlign)(Control_Category.identity(Control_Category.categoryFn));
};
var crosswalkArray = {
    crosswalk: function (dictAlignable) {
        return function (f) {
            return function (xs) {
                var cons = Data_These.these(Control_Applicative.pure(Control_Applicative.applicativeArray))(Control_Category.identity(Control_Category.categoryFn))(Data_Array.cons);
                var v = Data_Array.uncons(xs);
                if (v instanceof Data_Maybe.Nothing) {
                    return nil(dictAlignable);
                };
                if (v instanceof Data_Maybe.Just) {
                    return align(dictAlignable.Align0())(cons)(f(v.value0.head))(crosswalk(crosswalkArray)(dictAlignable)(f)(v.value0.tail));
                };
                throw new Error("Failed pattern match at Data.Align (line 121, column 20 - line 123, column 66): " + [ v.constructor.name ]);
            };
        };
    },
    Foldable0: function () {
        return Data_Foldable.foldableArray;
    },
    Functor1: function () {
        return Data_Functor.functorArray;
    }
};
var crosswalkLazyList = {
    crosswalk: function (dictAlignable) {
        return function (f) {
            return function (l) {
                var cons = Data_These.these(Control_Applicative.pure(Data_List_Lazy_Types.applicativeList))(Control_Category.identity(Control_Category.categoryFn))(Data_List_Lazy_Types.cons);
                var v = Data_List_Lazy_Types.step(l);
                if (v instanceof Data_List_Lazy_Types.Nil) {
                    return nil(dictAlignable);
                };
                if (v instanceof Data_List_Lazy_Types.Cons) {
                    return align(dictAlignable.Align0())(cons)(f(v.value0))(crosswalk(crosswalkLazyList)(dictAlignable)(f)(v.value1));
                };
                throw new Error("Failed pattern match at Data.Align (line 136, column 5 - line 138, column 62): " + [ v.constructor.name ]);
            };
        };
    },
    Foldable0: function () {
        return Data_List_Lazy_Types.foldableList;
    },
    Functor1: function () {
        return Data_List_Lazy_Types.functorList;
    }
};
var crosswalkList = {
    crosswalk: function (dictAlignable) {
        return function (f) {
            var cons = Data_These.these(Control_Applicative.pure(Data_List_Types.applicativeList))(Control_Category.identity(Control_Category.categoryFn))(Data_List_Types.Cons.create);
            return function (v) {
                if (v instanceof Data_List_Types.Nil) {
                    return nil(dictAlignable);
                };
                if (v instanceof Data_List_Types.Cons) {
                    return align(dictAlignable.Align0())(cons)(f(v.value0))(crosswalk(crosswalkList)(dictAlignable)(f)(v.value1));
                };
                throw new Error("Failed pattern match at Data.Align (line 128, column 17 - line 130, column 56): " + [ v.constructor.name ]);
            };
        };
    },
    Foldable0: function () {
        return Data_List_Types.foldableList;
    },
    Functor1: function () {
        return Data_List_Types.functorList;
    }
};
module.exports = {
    align: align,
    crosswalk: crosswalk,
    nil: nil,
    aligned: aligned,
    alignArray: alignArray,
    alignList: alignList,
    alignLazyList: alignLazyList,
    alignMaybe: alignMaybe,
    alignableArray: alignableArray,
    alignableList: alignableList,
    alignableLazyList: alignableLazyList,
    alignableMaybe: alignableMaybe,
    crosswalkThese: crosswalkThese,
    crosswalkArray: crosswalkArray,
    crosswalkList: crosswalkList,
    crosswalkLazyList: crosswalkLazyList,
    crosswalkMaybe: crosswalkMaybe
};
