"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var fail = function (dictMonadThrow) {
    var $33 = Control_Monad_Error_Class.throwError(dictMonadThrow);
    return function ($34) {
        return $33(Effect_Exception.error($34));
    };
};
var shouldContain = function (dictMonadThrow) {
    return function (dictShow) {
        return function (dictEq) {
            return function (dictShow1) {
                return function (dictFoldable) {
                    return function (c) {
                        return function (e) {
                            return Control_Applicative.when((dictMonadThrow.Monad0()).Applicative0())(Data_Foldable.notElem(dictFoldable)(dictEq)(e)(c))(fail(dictMonadThrow)(Data_Show.show(dictShow)(e) + (" \u2209 " + Data_Show.show(dictShow1)(c))));
                        };
                    };
                };
            };
        };
    };
};
var shouldEqual = function (dictMonadThrow) {
    return function (dictShow) {
        return function (dictEq) {
            return function (v1) {
                return function (v2) {
                    return Control_Applicative.when((dictMonadThrow.Monad0()).Applicative0())(Data_Eq.notEq(dictEq)(v1)(v2))(fail(dictMonadThrow)(Data_Show.show(dictShow)(v1) + (" \u2260 " + Data_Show.show(dictShow)(v2))));
                };
            };
        };
    };
};

// | Asserts that `m t` returns `t`
var shouldReturn = function (dictMonadThrow) {
    return function (dictEq) {
        return function (dictShow) {
            return function (ft) {
                return function (t) {
                    return Control_Bind.bind((dictMonadThrow.Monad0()).Bind1())(ft)(function (v) {
                        return shouldEqual(dictMonadThrow)(dictShow)(dictEq)(v)(t);
                    });
                };
            };
        };
    };
};
var shouldNotContain = function (dictMonadThrow) {
    return function (dictShow) {
        return function (dictEq) {
            return function (dictShow1) {
                return function (dictFoldable) {
                    return function (c) {
                        return function (e) {
                            return Control_Applicative.when((dictMonadThrow.Monad0()).Applicative0())(Data_Foldable.elem(dictFoldable)(dictEq)(e)(c))(fail(dictMonadThrow)(Data_Show.show(dictShow)(e) + (" \u2208 " + Data_Show.show(dictShow1)(c))));
                        };
                    };
                };
            };
        };
    };
};
var shouldNotEqual = function (dictMonadThrow) {
    return function (dictShow) {
        return function (dictEq) {
            return function (v1) {
                return function (v2) {
                    return Control_Applicative.when((dictMonadThrow.Monad0()).Applicative0())(Data_Eq.eq(dictEq)(v1)(v2))(fail(dictMonadThrow)(Data_Show.show(dictShow)(v1) + (" = " + Data_Show.show(dictShow)(v2))));
                };
            };
        };
    };
};

// | Asserts that `m t` does not return `t`
var shouldNotReturn = function (dictMonadThrow) {
    return function (dictEq) {
        return function (dictShow) {
            return function (ft) {
                return function (t) {
                    return Control_Bind.bind((dictMonadThrow.Monad0()).Bind1())(ft)(function (v) {
                        return shouldNotEqual(dictMonadThrow)(dictShow)(dictEq)(v)(t);
                    });
                };
            };
        };
    };
};
var shouldNotSatisfy = function (dictMonadThrow) {
    return function (dictShow) {
        return function (v) {
            return function (pred) {
                return Control_Applicative.when((dictMonadThrow.Monad0()).Applicative0())(pred(v))(fail(dictMonadThrow)(Data_Show.show(dictShow)(v) + " satisfies predicate, but should not"));
            };
        };
    };
};
var shouldSatisfy = function (dictMonadThrow) {
    return function (dictShow) {
        return function (v) {
            return function (pred) {
                return Control_Applicative.unless((dictMonadThrow.Monad0()).Applicative0())(pred(v))(fail(dictMonadThrow)(Data_Show.show(dictShow)(v) + " doesn't satisfy predicate"));
            };
        };
    };
};
var expectError = function (dictMonadError) {
    return function (a) {
        return Control_Bind.bind(((dictMonadError.MonadThrow0()).Monad0()).Bind1())(Control_Monad_Error_Class["try"](dictMonadError)(a))(function (e) {
            if (e instanceof Data_Either.Left) {
                return Control_Applicative.pure(((dictMonadError.MonadThrow0()).Monad0()).Applicative0())(Data_Unit.unit);
            };
            if (e instanceof Data_Either.Right) {
                return Control_Monad_Error_Class.throwError(dictMonadError.MonadThrow0())(Effect_Exception.error("Expected error"));
            };
            throw new Error("Failed pattern match at Test.Spec.Assertions (line 105, column 3 - line 107, column 51): " + [ e.constructor.name ]);
        });
    };
};
module.exports = {
    fail: fail,
    shouldEqual: shouldEqual,
    shouldNotEqual: shouldNotEqual,
    shouldContain: shouldContain,
    shouldNotContain: shouldNotContain,
    shouldNotSatisfy: shouldNotSatisfy,
    shouldSatisfy: shouldSatisfy,
    expectError: expectError,
    shouldReturn: shouldReturn,
    shouldNotReturn: shouldNotReturn
};
