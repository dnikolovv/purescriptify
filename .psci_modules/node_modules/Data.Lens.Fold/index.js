
// | This module defines functions for working with folds.
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Lens_Internal_Forget = require("../Data.Lens.Internal.Forget/index.js");
var Data_Lens_Types = require("../Data.Lens.Types/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Maybe_First = require("../Data.Maybe.First/index.js");
var Data_Maybe_Last = require("../Data.Maybe.Last/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Monoid_Additive = require("../Data.Monoid.Additive/index.js");
var Data_Monoid_Conj = require("../Data.Monoid.Conj/index.js");
var Data_Monoid_Disj = require("../Data.Monoid.Disj/index.js");
var Data_Monoid_Dual = require("../Data.Monoid.Dual/index.js");
var Data_Monoid_Endo = require("../Data.Monoid.Endo/index.js");
var Data_Monoid_Multiplicative = require("../Data.Monoid.Multiplicative/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Profunctor = require("../Data.Profunctor/index.js");
var Data_Profunctor_Choice = require("../Data.Profunctor.Choice/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unit = require("../Data.Unit/index.js");

// | Builds a `Fold` using an unfold.
var unfolded = function (dictMonoid) {
    return function (f) {
        return function (p) {
            var go = (function () {
                var $44 = Data_Maybe.maybe(Data_Monoid.mempty(dictMonoid))(function (v) {
                    return Data_Semigroup.append(dictMonoid.Semigroup0())(Data_Newtype.unwrap()(p)(v.value0))(go(v.value1));
                });
                return function ($45) {
                    return $44(f($45));
                };
            })();
            return go;
        };
    };
};

// | Replicates the elements of a fold.
var replicated = function (dictMonoid) {
    return function (i) {
        return function (v) {
            var go = function (v1) {
                return function (v2) {
                    if (v1 === 0) {
                        return Data_Monoid.mempty(Data_Monoid.monoidFn(dictMonoid));
                    };
                    return Data_Semigroup.append(Data_Semigroup.semigroupFn(dictMonoid.Semigroup0()))(v2)(go(v1 - 1 | 0)(v2));
                };
            };
            return go(i)(v);
        };
    };
};

// | Fold map over an `IndexedFold`.
var ifoldMapOf = function (p) {
    return function (f) {
        return Data_Newtype.unwrap()(p(Data_Tuple.uncurry(f)));
    };
};

// | Left fold over an `IndexedFold`.
var ifoldlOf = function (p) {
    return function (f) {
        return function (r) {
            var $46 = Data_Function.flip(Data_Newtype.unwrap())(r);
            var $47 = Data_Newtype.unwrap();
            var $48 = ifoldMapOf(p)(function (i) {
                var $50 = Data_Function.flip(f(i));
                return function ($51) {
                    return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($50($51)));
                };
            });
            return function ($49) {
                return $46($47($48($49)));
            };
        };
    };
};

// | Right fold over an `IndexedFold`.
var ifoldrOf = function (p) {
    return function (f) {
        return function (r) {
            var $52 = Data_Function.flip(Data_Newtype.unwrap())(r);
            var $53 = ifoldMapOf(p)(function (i) {
                var $55 = f(i);
                return function ($56) {
                    return Data_Monoid_Endo.Endo($55($56));
                };
            });
            return function ($54) {
                return $52($53($54));
            };
        };
    };
};

// | Collects the foci of an `IndexedFold` into a list.
var itoListOf = function (p) {
    return ifoldrOf(p)(function (i) {
        return function (x) {
            return function (xs) {
                return new Data_List_Types.Cons(new Data_Tuple.Tuple(i, x), xs);
            };
        };
    })(Data_List_Types.Nil.value);
};

// | Traverse the foci of an `IndexedFold`, discarding the results.
var itraverseOf_ = function (dictApplicative) {
    return function (p) {
        return function (f) {
            return ifoldrOf(p)(function (i) {
                return function (a) {
                    return function (fu) {
                        return Control_Apply.applySecond(dictApplicative.Apply0())(Data_Functor["void"]((dictApplicative.Apply0()).Functor0())(f(i)(a)))(fu);
                    };
                };
            })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
        };
    };
};

// | Flipped version of `itraverseOf_`.
var iforOf_ = function (dictApplicative) {
    var $57 = itraverseOf_(dictApplicative);
    return function ($58) {
        return Data_Function.flip($57($58));
    };
};

// | Find the first focus of an `IndexedFold` that satisfies a predicate, if
// | there is any.
var ifindOf = function (p) {
    return function (f) {
        return ifoldrOf(p)(function (i) {
            return function (a) {
                return Data_Maybe.maybe((function () {
                    var $38 = f(i)(a);
                    if ($38) {
                        return new Data_Maybe.Just(a);
                    };
                    return Data_Maybe.Nothing.value;
                })())(Data_Maybe.Just.create);
            };
        })(Data_Maybe.Nothing.value);
    };
};

// | Whether any focus of an `IndexedFold` satisfies a predicate.
var ianyOf = function (dictHeytingAlgebra) {
    return function (p) {
        return function (f) {
            var $59 = Data_Newtype.unwrap();
            var $60 = ifoldMapOf(p)(function (i) {
                var $62 = f(i);
                return function ($63) {
                    return Data_Monoid_Disj.Disj($62($63));
                };
            });
            return function ($61) {
                return $59($60($61));
            };
        };
    };
};

// | Whether all foci of an `IndexedFold` satisfy a predicate.
var iallOf = function (dictHeytingAlgebra) {
    return function (p) {
        return function (f) {
            var $64 = Data_Newtype.unwrap();
            var $65 = ifoldMapOf(p)(function (i) {
                var $67 = f(i);
                return function ($68) {
                    return Data_Monoid_Conj.Conj($67($68));
                };
            });
            return function ($66) {
                return $64($65($66));
            };
        };
    };
};

// | Folds over a `Foldable` container.
var folded = function (dictMonoid) {
    return function (dictFoldable) {
        return function (v) {
            return Data_Foldable.foldMap(dictFoldable)(dictMonoid)(v);
        };
    };
};

// | Maps and then folds all foci of a `Fold`.
var foldMapOf = Data_Newtype.under()()(Data_Lens_Internal_Forget.Forget);

// | Folds all foci of a `Fold` to one. Note that this is the same as `view`.
var foldOf = function (p) {
    return foldMapOf(p)(Control_Category.identity(Control_Category.categoryFn));
};

// | Left fold over a `Fold`.
var foldlOf = function (p) {
    return function (f) {
        return function (r) {
            var $69 = Data_Function.flip(Data_Newtype.unwrap())(r);
            var $70 = Data_Newtype.unwrap();
            var $71 = foldMapOf(p)((function () {
                var $73 = Data_Function.flip(f);
                return function ($74) {
                    return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($73($74)));
                };
            })());
            return function ($72) {
                return $69($70($71($72)));
            };
        };
    };
};

// | Right fold over a `Fold`.
var foldrOf = function (p) {
    return function (f) {
        return function (r) {
            var $75 = Data_Function.flip(Data_Newtype.unwrap())(r);
            var $76 = foldMapOf(p)(function ($78) {
                return Data_Monoid_Endo.Endo(f($78));
            });
            return function ($77) {
                return $75($76($77));
            };
        };
    };
};

// | The maximum of all foci of a `Fold`, if there is any.
var maximumOf = function (dictOrd) {
    return function (p) {
        var max = function (a) {
            return function (b) {
                var $40 = Data_Ord.greaterThan(dictOrd)(a)(b);
                if ($40) {
                    return a;
                };
                return b;
            };
        };
        return foldrOf(p)(function (a) {
            var $79 = Data_Maybe.maybe(a)(max(a));
            return function ($80) {
                return Data_Maybe.Just.create($79($80));
            };
        })(Data_Maybe.Nothing.value);
    };
};

// | The minimum of all foci of a `Fold`, if there is any.
var minimumOf = function (dictOrd) {
    return function (p) {
        var min = function (a) {
            return function (b) {
                var $41 = Data_Ord.lessThan(dictOrd)(a)(b);
                if ($41) {
                    return a;
                };
                return b;
            };
        };
        return foldrOf(p)(function (a) {
            var $81 = Data_Maybe.maybe(a)(min(a));
            return function ($82) {
                return Data_Maybe.Just.create($81($82));
            };
        })(Data_Maybe.Nothing.value);
    };
};

// | Collects the foci of a `Fold` into a list.
var toListOf = function (p) {
    return foldrOf(p)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
};

// | Collects the foci of a `Fold` into an array.
var toArrayOf = function (p) {
    var $83 = Data_Array.fromFoldable(Data_List_Types.foldableList);
    var $84 = toListOf(p);
    return function ($85) {
        return $83($84($85));
    };
};

// | Synonym for `toArrayOf`, reversed.
var toArrayOfOn = function (s) {
    return function (p) {
        return toArrayOf(p)(s);
    };
};

// | Synonym for `toListOf`, reversed.
var toListOfOn = function (s) {
    return function (p) {
        return toListOf(p)(s);
    };
};

// | Traverse the foci of a `Fold`, discarding the results.
var traverseOf_ = function (dictApplicative) {
    return function (p) {
        return function (f) {
            return foldrOf(p)(function (a) {
                return function (fu) {
                    return Control_Apply.applySecond(dictApplicative.Apply0())(Data_Functor["void"]((dictApplicative.Apply0()).Functor0())(f(a)))(fu);
                };
            })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
        };
    };
};

// | Determines whether a `Fold` has at least one focus.
var has = function (dictHeytingAlgebra) {
    return function (p) {
        var $86 = Data_Newtype.unwrap();
        var $87 = foldMapOf(p)(Data_Function["const"](Data_HeytingAlgebra.tt(dictHeytingAlgebra)));
        return function ($88) {
            return $86($87($88));
        };
    };
};

// | Determines whether a `Fold` does not have a focus.
var hasn$primet = function (dictHeytingAlgebra) {
    return function (p) {
        var $89 = Data_Newtype.unwrap();
        var $90 = foldMapOf(p)(Data_Function["const"](Data_HeytingAlgebra.ff(dictHeytingAlgebra)));
        return function ($91) {
            return $89($90($91));
        };
    };
};

// | The last focus of a `Fold`, if there is any.
var lastOf = function (p) {
    var $92 = Data_Newtype.unwrap();
    var $93 = foldMapOf(p)(function ($95) {
        return Data_Maybe_Last.Last(Data_Maybe.Just.create($95));
    });
    return function ($94) {
        return $92($93($94));
    };
};

// | The number of foci of a `Fold`.
var lengthOf = function (p) {
    var $96 = Data_Newtype.unwrap();
    var $97 = foldMapOf(p)(Data_Function["const"](1));
    return function ($98) {
        return $96($97($98));
    };
};

// | Previews the first value of a fold, if there is any.
var preview = function (p) {
    var $99 = Data_Newtype.unwrap();
    var $100 = foldMapOf(p)(function ($102) {
        return Data_Maybe_First.First(Data_Maybe.Just.create($102));
    });
    return function ($101) {
        return $99($100($101));
    };
};

// | Synonym for `preview`, flipped.
var previewOn = function (s) {
    return function (p) {
        return preview(p)(s);
    };
};

// | The product of all foci of a `Fold`.
var productOf = function (dictSemiring) {
    return function (p) {
        var $103 = Data_Newtype.unwrap();
        var $104 = foldMapOf(p)(Data_Monoid_Multiplicative.Multiplicative);
        return function ($105) {
            return $103($104($105));
        };
    };
};

// | Sequence the foci of a `Fold`, pulling out an `Applicative`, and ignore
// | the result. If you need the result, see `sequenceOf` for `Traversal`s.
var sequenceOf_ = function (dictApplicative) {
    return function (p) {
        var $106 = Data_Function.flip(Data_Newtype.unwrap())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
        var $107 = foldMapOf(p)(function (f) {
            return function (v) {
                return Control_Apply.applySecond(dictApplicative.Apply0())(f)(v);
            };
        });
        return function ($108) {
            return $106($107($108));
        };
    };
};

// | The sum of all foci of a `Fold`.
var sumOf = function (dictSemiring) {
    return function (p) {
        var $109 = Data_Newtype.unwrap();
        var $110 = foldMapOf(p)(Data_Monoid_Additive.Additive);
        return function ($111) {
            return $109($110($111));
        };
    };
};

// | The first focus of a `Fold`, if there is any. Synonym for `preview`.
var firstOf = function (p) {
    var $112 = Data_Newtype.unwrap();
    var $113 = foldMapOf(p)(function ($115) {
        return Data_Maybe_First.First(Data_Maybe.Just.create($115));
    });
    return function ($114) {
        return $112($113($114));
    };
};

// | Find the first focus of a `Fold` that satisfies a predicate, if there is any.
var findOf = function (p) {
    return function (f) {
        return foldrOf(p)(function (a) {
            return Data_Maybe.maybe((function () {
                var $42 = f(a);
                if ($42) {
                    return new Data_Maybe.Just(a);
                };
                return Data_Maybe.Nothing.value;
            })())(Data_Maybe.Just.create);
        })(Data_Maybe.Nothing.value);
    };
};

// | Filters on a predicate.
var filtered = function (dictChoice) {
    return function (f) {
        var $116 = Data_Profunctor.dimap(dictChoice.Profunctor0())(function (x) {
            var $43 = f(x);
            if ($43) {
                return new Data_Either.Right(x);
            };
            return new Data_Either.Left(x);
        })(Data_Either.either(Control_Category.identity(Control_Category.categoryFn))(Control_Category.identity(Control_Category.categoryFn)));
        var $117 = Data_Profunctor_Choice.right(dictChoice);
        return function ($118) {
            return $116($117($118));
        };
    };
};

// | Whether any focus of a `Fold` satisfies a predicate.
var anyOf = function (dictHeytingAlgebra) {
    return function (p) {
        return function (f) {
            var $119 = Data_Newtype.unwrap();
            var $120 = foldMapOf(p)(function ($122) {
                return Data_Monoid_Disj.Disj(f($122));
            });
            return function ($121) {
                return $119($120($121));
            };
        };
    };
};

// | Whether a `Fold` contains a given element.
var elemOf = function (dictEq) {
    return function (p) {
        return function (a) {
            return anyOf(Data_HeytingAlgebra.heytingAlgebraBoolean)(p)(function (v) {
                return Data_Eq.eq(dictEq)(v)(a);
            });
        };
    };
};

// | The disjunction of all foci of a `Fold`.
var orOf = function (dictHeytingAlgebra) {
    return function (p) {
        return anyOf(dictHeytingAlgebra)(p)(Control_Category.identity(Control_Category.categoryFn));
    };
};

// | Whether all foci of a `Fold` satisfy a predicate.
var allOf = function (dictHeytingAlgebra) {
    return function (p) {
        return function (f) {
            var $123 = Data_Newtype.unwrap();
            var $124 = foldMapOf(p)(function ($126) {
                return Data_Monoid_Conj.Conj(f($126));
            });
            return function ($125) {
                return $123($124($125));
            };
        };
    };
};

// | The conjunction of all foci of a `Fold`.
var andOf = function (dictHeytingAlgebra) {
    return function (p) {
        return allOf(dictHeytingAlgebra)(p)(Control_Category.identity(Control_Category.categoryFn));
    };
};

// | Whether a `Fold` not contains a given element.
var notElemOf = function (dictEq) {
    return function (p) {
        return function (a) {
            return allOf(Data_HeytingAlgebra.heytingAlgebraBoolean)(p)(function (v) {
                return Data_Eq.notEq(dictEq)(v)(a);
            });
        };
    };
};
module.exports = {
    previewOn: previewOn,
    toListOfOn: toListOfOn,
    preview: preview,
    foldOf: foldOf,
    foldMapOf: foldMapOf,
    foldrOf: foldrOf,
    foldlOf: foldlOf,
    toListOf: toListOf,
    firstOf: firstOf,
    lastOf: lastOf,
    maximumOf: maximumOf,
    minimumOf: minimumOf,
    allOf: allOf,
    anyOf: anyOf,
    andOf: andOf,
    orOf: orOf,
    elemOf: elemOf,
    notElemOf: notElemOf,
    sumOf: sumOf,
    productOf: productOf,
    lengthOf: lengthOf,
    findOf: findOf,
    sequenceOf_: sequenceOf_,
    traverseOf_: traverseOf_,
    has: has,
    "hasn't": hasn$primet,
    replicated: replicated,
    filtered: filtered,
    folded: folded,
    unfolded: unfolded,
    toArrayOf: toArrayOf,
    toArrayOfOn: toArrayOfOn,
    ifoldMapOf: ifoldMapOf,
    ifoldrOf: ifoldrOf,
    ifoldlOf: ifoldlOf,
    iallOf: iallOf,
    ianyOf: ianyOf,
    ifindOf: ifindOf,
    itoListOf: itoListOf,
    itraverseOf_: itraverseOf_,
    iforOf_: iforOf_
};
