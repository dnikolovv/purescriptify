"use strict";
var $foreign = require("./foreign.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Bounded = require("../Data.Bounded/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Number = require("../Data.Number/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var $$Math = require("../Math/index.js");

// | The number of unique digits (including zero) used to represent integers in
// | a specific base.
var Radix = function (x) {
    return x;
};

// | A type for describing whether an integer is even or odd.
// |
// | The `Ord` instance considers `Even` to be less than `Odd`.
// |
// | The `Semiring` instance allows you to ask about the parity of the results
// | of arithmetical operations, given only the parities of the inputs. For
// | example, the sum of an odd number and an even number is odd, so
// | `Odd + Even == Odd`. This also works for multiplication, eg. the product
// | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.
// |
// | More generally, we have that
// |
// | ```purescript
// | parity x + parity y == parity (x + y)
// | parity x * parity y == parity (x * y)
// | ```
// |
// | for any integers `x`, `y`. (A mathematician would say that `parity` is a
// | *ring homomorphism*.)
// |
// | After defining addition and multiplication on `Parity` in this way, the
// | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.
// | This `Semiring` instance actually turns out to be a `Field`.
var Even = (function () {
    function Even() {

    };
    Even.value = new Even();
    return Even;
})();

// | A type for describing whether an integer is even or odd.
// |
// | The `Ord` instance considers `Even` to be less than `Odd`.
// |
// | The `Semiring` instance allows you to ask about the parity of the results
// | of arithmetical operations, given only the parities of the inputs. For
// | example, the sum of an odd number and an even number is odd, so
// | `Odd + Even == Odd`. This also works for multiplication, eg. the product
// | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.
// |
// | More generally, we have that
// |
// | ```purescript
// | parity x + parity y == parity (x + y)
// | parity x * parity y == parity (x * y)
// | ```
// |
// | for any integers `x`, `y`. (A mathematician would say that `parity` is a
// | *ring homomorphism*.)
// |
// | After defining addition and multiplication on `Parity` in this way, the
// | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.
// | This `Semiring` instance actually turns out to be a `Field`.
var Odd = (function () {
    function Odd() {

    };
    Odd.value = new Odd();
    return Odd;
})();
var showParity = {
    show: function (v) {
        if (v instanceof Even) {
            return "Even";
        };
        if (v instanceof Odd) {
            return "Odd";
        };
        throw new Error("Failed pattern match at Data.Int (line 111, column 1 - line 113, column 19): " + [ v.constructor.name ]);
    }
};

// | Create a `Radix` from a number between 2 and 36.
var radix = function (n) {
    if (n >= 2 && n <= 36) {
        return new Data_Maybe.Just(n);
    };
    if (Data_Boolean.otherwise) {
        return Data_Maybe.Nothing.value;
    };
    throw new Error("Failed pattern match at Data.Int (line 192, column 1 - line 192, column 28): " + [ n.constructor.name ]);
};

// | The negation of `even`.
// |
// | ``` purescript
// | odd 0 == false
// | odd 1 == true
// | ```
var odd = function (x) {
    return (x & 1) !== 0;
};

// | The base-8 system.
var octal = 8;

// | The base-16 system.
var hexadecimal = 16;

// | Like `fromString`, but the integer can be specified in a different base.
// |
// | Example:
// | ``` purs
// | fromStringAs binary      "100" == Just 4
// | fromStringAs hexadecimal "ff"  == Just 255
// | ```
var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

// | Reads an `Int` from a `String` value. The number must parse as an integer
// | and fall within the valid range of values for the `Int` type, otherwise
// | `Nothing` is returned.
var fromString = fromStringAs(10);

// | Creates an `Int` from a `Number` value. The number must already be an
// | integer and fall within the valid range of values for the `Int` type
// | otherwise `Nothing` is returned.
var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

// | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.
// | This function will return 0 if the input is `NaN` or an `Infinity`.
var unsafeClamp = function (x) {
    if (!Data_Number["isFinite"](x)) {
        return 0;
    };
    if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {
        return Data_Bounded.top(Data_Bounded.boundedInt);
    };
    if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {
        return Data_Bounded.bottom(Data_Bounded.boundedInt);
    };
    if (Data_Boolean.otherwise) {
        return Data_Maybe.fromMaybe(0)(fromNumber(x));
    };
    throw new Error("Failed pattern match at Data.Int (line 66, column 1 - line 66, column 29): " + [ x.constructor.name ]);
};

// | Convert a `Number` to an `Int`, by taking the nearest integer to the
// | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`
// | values return 0.
var round = function ($23) {
    return unsafeClamp($$Math.round($23));
};

// | Convert a `Number` to an `Int`, by taking the closest integer equal to or
// | less than the argument. Values outside the `Int` range are clamped, `NaN`
// | and `Infinity` values return 0.
var floor = function ($24) {
    return unsafeClamp($$Math.floor($24));
};

// | Returns whether an `Int` is an even number.
// |
// | ``` purescript
// | even 0 == true
// | even 1 == false
// | ```
var even = function (x) {
    return (x & 1) === 0;
};

// | Returns whether an `Int` is `Even` or `Odd`.
// |
// | ``` purescript
// | parity 0 == Even
// | parity 1 == Odd
// | ```
var parity = function (n) {
    var $14 = even(n);
    if ($14) {
        return Even.value;
    };
    return Odd.value;
};
var eqParity = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Even && y instanceof Even) {
                return true;
            };
            if (x instanceof Odd && y instanceof Odd) {
                return true;
            };
            return false;
        };
    }
};
var ordParity = {
    compare: function (x) {
        return function (y) {
            if (x instanceof Even && y instanceof Even) {
                return Data_Ordering.EQ.value;
            };
            if (x instanceof Even) {
                return Data_Ordering.LT.value;
            };
            if (y instanceof Even) {
                return Data_Ordering.GT.value;
            };
            if (x instanceof Odd && y instanceof Odd) {
                return Data_Ordering.EQ.value;
            };
            throw new Error("Failed pattern match at Data.Int (line 109, column 1 - line 109, column 40): " + [ x.constructor.name, y.constructor.name ]);
        };
    },
    Eq0: function () {
        return eqParity;
    }
};
var semiringParity = {
    zero: Even.value,
    add: function (x) {
        return function (y) {
            var $19 = Data_Eq.eq(eqParity)(x)(y);
            if ($19) {
                return Even.value;
            };
            return Odd.value;
        };
    },
    one: Odd.value,
    mul: function (v) {
        return function (v1) {
            if (v instanceof Odd && v1 instanceof Odd) {
                return Odd.value;
            };
            return Even.value;
        };
    }
};
var ringParity = {
    sub: Data_Semiring.add(semiringParity),
    Semiring0: function () {
        return semiringParity;
    }
};
var divisionRingParity = {
    recip: Control_Category.identity(Control_Category.categoryFn),
    Ring0: function () {
        return ringParity;
    }
};

// | The base-10 system.
var decimal = 10;
var commutativeRingParity = {
    Ring0: function () {
        return ringParity;
    }
};
var euclideanRingParity = {
    degree: function (v) {
        if (v instanceof Even) {
            return 0;
        };
        if (v instanceof Odd) {
            return 1;
        };
        throw new Error("Failed pattern match at Data.Int (line 131, column 1 - line 135, column 17): " + [ v.constructor.name ]);
    },
    div: function (x) {
        return function (v) {
            return x;
        };
    },
    mod: function (v) {
        return function (v1) {
            return Even.value;
        };
    },
    CommutativeRing0: function () {
        return commutativeRingParity;
    }
};

// | Convert a `Number` to an `Int`, by taking the closest integer equal to or
// | greater than the argument. Values outside the `Int` range are clamped,
// | `NaN` and `Infinity` values return 0.
var ceil = function ($25) {
    return unsafeClamp($$Math.ceil($25));
};
var boundedParity = {
    bottom: Even.value,
    top: Odd.value,
    Ord0: function () {
        return ordParity;
    }
};

// | The base-2 system.
var binary = 2;

// | The base-36 system.
var base36 = 36;
module.exports = {
    fromNumber: fromNumber,
    ceil: ceil,
    floor: floor,
    round: round,
    fromString: fromString,
    radix: radix,
    binary: binary,
    octal: octal,
    decimal: decimal,
    hexadecimal: hexadecimal,
    base36: base36,
    fromStringAs: fromStringAs,
    Even: Even,
    Odd: Odd,
    parity: parity,
    even: even,
    odd: odd,
    eqParity: eqParity,
    ordParity: ordParity,
    showParity: showParity,
    boundedParity: boundedParity,
    semiringParity: semiringParity,
    ringParity: ringParity,
    commutativeRingParity: commutativeRingParity,
    euclideanRingParity: euclideanRingParity,
    divisionRingParity: divisionRingParity,
    toNumber: $foreign.toNumber,
    toStringAs: $foreign.toStringAs,
    quot: $foreign.quot,
    rem: $foreign.rem,
    pow: $foreign.pow
};
