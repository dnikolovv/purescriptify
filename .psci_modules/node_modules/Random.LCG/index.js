"use strict";
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Show = require("../Data.Show/index.js");
var Effect = require("../Effect/index.js");
var Effect_Random = require("../Effect.Random/index.js");
var $$Math = require("../Math/index.js");

// | A seed for the linear congruential generator. We omit a `Semiring`
// | instance because there is no `zero` value, as 0 is not an acceptable
// | seed for the generator.
var Seed = function (x) {
    return x;
};
var unSeed = function (v) {
    return v;
};
var showSeed = {
    show: function (v) {
        return "Seed " + Data_Show.show(Data_Show.showInt)(v);
    }
};

// | The minimum permissible Seed value.
var seedMin = 1;

// | The *modulus*: a magic constant for the linear congruential generator.
// | It is equal to 2^31 - 1, a Mersenne prime. It is useful for this value to
// | be prime, because then the requirement of the initial seed being coprime
// | to the modulus is satisfied when the seed is between 1 and lcgM - 1.
var lcgM = 2147483647;

// | The maximum permissible Seed value.
var seedMax = lcgM - 1 | 0;
var mkSeed = function (x) {
    var ensureBetween = function (min) {
        return function (max) {
            return function (n) {
                var rangeSize = max - min | 0;
                var n$prime = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(n)(rangeSize);
                var $13 = n$prime < min;
                if ($13) {
                    return n$prime + max | 0;
                };
                return n$prime;
            };
        };
    };
    return ensureBetween(seedMin)(seedMax)(x);
};

// | Create a random seed
var randomSeed = Data_Functor.map(Effect.functorEffect)(mkSeed)(Effect_Random.randomInt(seedMin)(seedMax));

// | The *increment*: a magic constant for the linear congruential generator
var lcgC = 0;

// | The *multiplier*: a magic constant for the linear congruential generator
var lcgA = 48271;

// | Perturb a seed value
// Note that `Int` operations are truncated to 32-bits, so we convert to
// `Number` for this calculation to avoid overflow errors.
var lcgPerturb = function (d) {
    return function (v) {
        return Data_Maybe.fromJust()(Data_Int.fromNumber($$Math.remainder(Data_Int.toNumber(lcgA) * Data_Int.toNumber(v) + Data_Int.toNumber(d))(Data_Int.toNumber(lcgM))));
    };
};

// | Step the linear congruential generator
var lcgNext = lcgPerturb(lcgC);
var eqSeed = {
    eq: function (x) {
        return function (y) {
            return x === y;
        };
    }
};
var ordSeed = {
    compare: function (x) {
        return function (y) {
            return Data_Ord.compare(Data_Ord.ordInt)(x)(y);
        };
    },
    Eq0: function () {
        return eqSeed;
    }
};
module.exports = {
    mkSeed: mkSeed,
    unSeed: unSeed,
    randomSeed: randomSeed,
    lcgA: lcgA,
    lcgC: lcgC,
    lcgM: lcgM,
    lcgNext: lcgNext,
    lcgPerturb: lcgPerturb,
    eqSeed: eqSeed,
    ordSeed: ordSeed,
    showSeed: showSeed
};
